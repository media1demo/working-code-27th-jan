const effects = 
[
    "lrsqueeze",
    "persanticlockrotate",
    "dancechest",
    "snake",
    "legdance",
    "randomdance",
    "moverightside",
    "movingrightsideplus",
    "rightleft",
    "downzeroup",
    "tinyshoulder",
    "tinyshouldermovements",
    "downzeroupdown",
    "leftrightdance",
    "yogaleft",
    "hrithikdance",
    "curvedance",
    "angrybirds",
    "upjump",
    "downzoom",
    "updown",
    "jumpleft",
    "explosion",
    'explosion1',
    "firework",
    "leftbottomzerorighttop",
    "rainbow",
    "zoommove",
    "upzoomdownsmall",
    "neonblue",
    "bothsideclone",
    "bulgepinchreal",
    "gravitybounce",
    "squeezex2",
    "squeezey2",
    "createround",
    "topviewwaterripple",
    "fullleft",
    "clock",
    "butterfly1",
    "twist",
    "tiltsmall",
    "fullupchange",
    "tattoo",
    "lipshape",
    "reallips",
    "parallaxselectedregion",
    "leftVR",
    "leftVR1",
    "rotatey",
    "rotatey3d",
    "leftrightVR",
    "fullimageextend",
    "stonewriting",
    "downchange",
    "sideextension",
    "bodytoashes",
    "whiteline",
    "leftdownzerorightdown",
    "projectile",
    "projectile1",
    'fanceiling',
    'fanceiling1',
    'fanceiling2',
    'fanceilingfast',
    'fanceilingfast1',
    "projectile2",
    "projectile3",
    "projectiletopleft",
    "reverseclock",
    "lefttoprightcircle",
    "infinite",
    "spongeball",
    "downelongate",
    "standing",
    "rightsidesitting",
    "rightsidesitting1",
    "running2",
    "running3",
    "running4",
    "running5",
    "running6",
    "running7",
    "running8",
    "running9",
    "running10",
    "running11",
    "running12",
    "running14",
    "running15",
    "running16",
    "running17",
    "running18",
    "running19",
    "running20",
    "running21",
    "running22",
    "running23",
    "running24",
    "running25",
    "running26",
    "running27",
     "running28",
    "running29",
    "running30",
    "running31",
    "running32",
    "running33",
    "running34",
    "running35",
    "running36",
    "running37",
    "backgroundpredict2",
    "backgroundpredict3",
    "backgroundpredict4",
    "backgroundpredict5",
    "backgroundpredict6",
    "backgroundpredict7",
    "backgroundpredict",
    "background",
    "BHUE",
    "colorchange",
    "blockDissolve1",
    "blockDissolve",
    "bottom10",
    "up10",
    "bottomleft",
    "fullright",
    "bottomright",
    "upright",
    "upleft",
    "brightness1",
    "brightness3",
    "brightness",
    "bulgepinch101",
    "bulgepinch103",
    "bulgepinch104",
    "bulgepinch102",
    "scale",
    "bulgepinch10",
    "bulgePinch1",
    "bulgePinch2",
    "bulgePinch3",
    "bulgePinch4",
    "colorHalfTone",
    "colorUtils",
    "replaceimage1",
    "denoise1",
    "depthAnd3DEffect",
    "depthEstimation",
    "depthMap",
    "dotScreen",
    "down10",
    "downleft10",
    "downright10",
    "droste10",
    "droste11",
    "edgework101",
    "edgework102",
    "edgework10",
    "faceindexmovement1",
    "hexagonalPixelate",
    "hue10",
    "hue1",
    "hue",
    'reallips1',
    'reallips2',
    'reallips3',
    'reallips4',
    'reallips5',
    'reallips6',
    'reallips7',
    'reallips8',
    "indexlips",
    "indexlipsqueeze",
    "indexlipscartoon",
    "outline",
    "ink1",
    "invert",
    "jump",
    "kaleidoscopefullimage",
    "kaleidoscope",
    "left10",
    "right10",
    "lipsync1",
    "lensBlur",
    "lipsync",
    "lipsync10",
    "parallax3d",
    "parallaxdown10",
    "parallaxdownsmall10",
    "parallaxleft10",
    "parallaxleftlarge10",
    "border",
    "parallaxVR10",
    "parallaxleftsmall10",
    "parallaxVR101",
    "perspectiveCubeMap",
    "perspectiveVRcubemap",
    "rotatecentre",
    "perspectiveVRcubemap1",
    "perspectiveVRcubemap2",
    "perspectiveCurve",
    "fullimagesidebyside",
    "perspectiveCurvecopy3",
    "cylinder",
    "perspectiveCylinder",
    "perspectiveEmboss",
    "perspectiveextend",
    "perspectiveField",
    "perspectiveFieldselectedregion",
    "perspectiveFisheye",
    "perspectiveFold",
    "perspectivestepup",
    "perspectiverotate1",
    "perspectiveKaleidoscope",
    "perspectiveMosaic",
    "perspectivePinch",
    "perspectivePinch1",
    "perspectivePosterize",
    "perspectiveRotate",
    "perspectiveSkew",
    "perspectiveSphere",
    "perspectivesqueeze1",
    "perspectiveSqueeze",
    "perspectiveTilt1",
    "perspectiveTilt2",
    "zoom",
    "perspectiveTunnel",
    "perspectiveTwist",
    "perspectiveTwist1",
    "perspectiveVortex",
    "bookfold",
    "perspectiveWarp",
    "perspectiveWave",
    "perspectiveWrap",
    "perspectiveZoom",
    "perspectiveZoom1",
    "posedetection",
    "pp2",
    "mesh",
    "pp3",
    "pp4",
    "pp5",
    "randompic",
    "removebg",
    
    "rotatebottomleftccw",
    "rotatebottomleftcw",
    "rotatebottomleftvariable",
    "rotatebottomleft",
    "projectileleft",
    "rotatebottomrightccw",
    "projectileleft1",
    "rotatebottomrightcw",
    "rotatebottomright",
    "rotatetopleftccw",
    "rotatetopleftcw",
    "rotatetopleft",
    "rotatetoprightccw",
    "rotatetoprightcw",
    "3d",
    "runninganti",
    "balloon",
    "runningleg2",
    "runningleg3",
    "runningleg4",
    "oscillate",
    "runningleg",
    "running",
    "saturation10",
    "segmentation10",
    "segmentation11",
    "segmentation12",
    "segmentimageselectedregion1",
    "segmentimageselectedregion",
    "sittinganti",
    "sitting",
    "smooth-edges",
    "smoothedgelight",
    "smoothedges2",
    "squeeze1",
    "widen",
    "squeeze2",
    "squeeze3",
    "squeezex1",
    "squeezex",
    "squeezey1",
    "squeezey",
    "swirl",
    "threeDE",
    "droste",
    "running1"
]


const animationEffects = [
    // 'perspectiveTilt', 'perspectiveSqueeze', 'perspectiveCurve', 'perspectiveTwist',
    // 'perspectiveFisheye', 'perspective', 'perspectiveRotate', 'perspectiveSkew',
    // 'perspectiveWarp', 'perspectiveZoom', 'perspectiveTunnel', 'perspectiveSphere',
    // 'perspectiveCylinder', 'perspectiveRipple', 'perspectiveVortex', 'perspectiveFold',
    // 'perspectivePixelate', 'perspectiveEmboss', 'perspectiveMosaic',
    // 'perspectiveOilPainting', 'perspectivePosterize'
];

function toggleAnimationEffects() {
    const animationCheckbox = document.getElementById('animationCheckbox');
    const animationCheckboxLabel = document.getElementById('animationCheckboxLabel');
    const isChecked = animationCheckbox.checked;

    // Update the label text based on the checkbox state
    animationCheckboxLabel.textContent = isChecked ? 'Unselect All' : 'Select All';

    // Toggle all animation effects
    animationEffects.forEach(effect => {
        const checkbox = document.getElementById(effect + 'Checkbox');
        console.log(checkbox); // Should log the checkbox element

        if (checkbox) {
            checkbox.checked = isChecked;
        }
    });

    updateMasterCheckbox();
}

// function toggleAllEffects() {
//     const isChecked = masterCheckbox.checked;
//     effects.forEach(effect => {
//         if (!animationEffects.includes(effect)) {
//             document.getElementById(effect + 'Checkbox').checked = isChecked;
//         }
//     });
// }
function toggleAllEffects() {
    const isChecked = masterCheckbox.checked;
    const searchTerm = effectSearchBar.value.toLowerCase();
    
    effects.forEach(effect => {
        if (!animationEffects.includes(effect)) {
            const checkbox = document.getElementById(effect + 'Checkbox');
            if (checkbox) {
                // Only toggle checkboxes for visible effects (matching search)
                const effectDiv = checkbox.closest('.effect-control');
                if (effectDiv.style.display !== 'none') {
                    checkbox.checked = isChecked;
                }
            }
        }
    });
    
    // Update displayed buttons after toggling checkboxes
    displayEffectButtons();
}
function updateMasterCheckbox() {
    const effectCheckboxes = effects.filter(effect => !animationEffects.includes(effect));
    const allChecked = effectCheckboxes.every(effect => document.getElementById(effect + 'Checkbox').checked);
    const anyChecked = effectCheckboxes.some(effect => document.getElementById(effect + 'Checkbox').checked);
    masterCheckbox.checked = allChecked;
    masterCheckbox.indeterminate = anyChecked && !allChecked;
}

function updateEffectDisplay(effect) {
    const effectButton = document.querySelector(`.effect-button[data-effect="${effect}"]`);
    if (effectButton) effectButton.classList.add('processed');
}


let startTime = 0;
let endTime = 0;
let timerInterval;

function startTimer() {
    startTime = Date.now();
    updateTimer();
    timerInterval = setInterval(updateTimer, 10); // Update every 10ms for smoother display
}

function endTimer() {
    endTime = Date.now();
    clearInterval(timerInterval);
    updateTimer();
}

function updateTimer() {
    const currentTime = endTime || Date.now();
    const elapsedTime = currentTime - startTime;
    
    // Convert to minutes, seconds, and milliseconds
    const minutes = Math.floor(elapsedTime / 60000);
    const seconds = Math.floor((elapsedTime % 60000) / 1000);
    const milliseconds = elapsedTime % 1000;

    // Format the time as MM:SS:mmm
    const displayTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
    
    // Update the timer display
    document.getElementById('timer').textContent = displayTime;
}

// Reset function if needed
function resetTimer() {
    clearInterval(timerInterval);
    startTime = 0;
    endTime = 0;
    document.getElementById('timer').textContent = '00:00:000';
}


function applyEffect(effect, imageData, value, selectedRegions) {
    const startTime = Date.now(); // Record start time when posting to worker
    
    return new Promise((resolve, reject) => {
        if (!workers[effect]) {
            reject(new Error(`Worker for effect ${effect} not found`));
            return;
        }

        workers[effect].onmessage = function(e) {
            const endTime = Date.now(); // Record end time when receiving response
            const executionTime = endTime - startTime;
            
            // Update timer display
            const timerElement = document.getElementById('timer');
            if (timerElement) {
                // Convert to minutes, seconds, milliseconds
                const minutes = Math.floor(executionTime / 60000);
                const seconds = Math.floor((executionTime % 60000) / 1000);
                const milliseconds = executionTime % 1000;
                
                // Format as MM:SS:mmm
                timerElement.textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
            }

            if (e.data.error) {
                reject(new Error(`Error in ${effect} worker: ${e.data.error}`));
            } else {
                // console.log('e.data.segmentedImages :>> ', e.data.segmentedImages);
                // console.log(e.data);
                resolve(e.data.segmentedImages[0]); // Updated to match worker response format
            }
        };

        workers[effect].onerror = function(error) {
            const endTime = Date.now();
            const executionTime = endTime - startTime;
            
            // Update timer even in case of error
            const timerElement = document.getElementById('timer');
            if (timerElement) {
                const minutes = Math.floor(executionTime / 60000);
                const seconds = Math.floor((executionTime % 60000) / 1000);
                const milliseconds = executionTime % 1000;
                timerElement.textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
            }
            
            reject(new Error(`Error in ${effect} worker: ${error.message}`));
        };

        // Send data to the worker
        workers[effect].postMessage({
            imageData: imageData,
            value: value,
            selectedRegions: selectedRegions
        });
    });
}


// function displayEffectButtons() {
//     Array.from(effectControls.children).forEach(child => {
//         if (child.tagName !== 'DIV') { // Assuming checkboxes are in div containers
//             child.remove();
//         }
//     });

//     effects.forEach(effect => {
//         const button = document.createElement('button');
//         button.className = 'effect-button';
//         button.textContent = effect;
//         button.dataset.effect = effect;
//         button.dataset.active = 'true';
//         button.addEventListener('mouseenter', () => displayEffectImages(effect));
//         button.addEventListener('click', () => { toggleEffect(button); displayEffectImages(effect); });
        
//         const checkboxDiv = document.querySelector(`.effect-control input[id="${effect}Checkbox"]`).closest('.effect-control');
//         checkboxDiv.insertAdjacentElement('afterend', button);
//     });
// }


// function displayEffectButtons() {
//     // Clear existing buttons
//     Array.from(effectControls.children).forEach(child => {
//         if (child.tagName !== 'DIV') { // Assuming checkboxes are in div containers
//             child.remove();
//         }
//     });

//     // Sort effects: checked effects first, then unchecked
//     const sortedEffects = effects.sort((a, b) => {
//         const aChecked = document.getElementById(`${a}Checkbox`).checked;
//         const bChecked = document.getElementById(`${b}Checkbox`).checked;
//         if (aChecked && !bChecked) return -1; // a comes first
//         if (!aChecked && bChecked) return 1;  // b comes first
//         return 0; // no change in order
//     });

//     // Create and display buttons in the sorted order
//     sortedEffects.forEach(effect => {
//         const button = document.createElement('button');
//         button.className = 'effect-button';
//         button.textContent = effect;
//         button.dataset.effect = effect;
//         button.dataset.active = 'true';
//         button.addEventListener('mouseenter', () => displayEffectImages(effect));
//         button.addEventListener('click', () => { toggleEffect(button); displayEffectImages(effect); });
        
//         const checkboxDiv = document.querySelector(`.effect-control input[id="${effect}Checkbox"]`).closest('.effect-control');
//         checkboxDiv.insertAdjacentElement('afterend', button);
//     });
// }

// function displayEffectButtons() {
//     // Clear existing buttons
//     Array.from(effectControls.children).forEach(child => {
//         if (child.tagName !== 'DIV') { // Assuming checkboxes are in div containers
//             child.remove();
//         }
//     });

//     // Sort effects: checked effects first, then unchecked
//     const sortedEffects = effects.sort((a, b) => {
//         const aChecked = document.getElementById(`${a}Checkbox`).checked;
//         const bChecked = document.getElementById(`${b}Checkbox`).checked;
//         if (aChecked && !bChecked) return -1; // a comes first
//         if (!aChecked && bChecked) return 1;  // b comes first
//         return 0; // no change in order
//     });

//     // Create and display buttons in the sorted order
//     sortedEffects.forEach(effect => {

//         const isChecked = document.getElementById(`${effect}Checkbox`).checked;

//         // Only create a button for checked effects
//         if (isChecked) {

//         const button = document.createElement('button');
//         button.className = 'effect-button';
//         button.textContent = effect;
//         button.dataset.effect = effect;
//         button.dataset.active = 'true';
//         button.addEventListener('mouseenter', () => displayEffectImages(effect));
//         button.addEventListener('click', () => { toggleEffect(button); displayEffectImages(effect); });
        
//         const checkboxDiv = document.querySelector(`.effect-control input[id="${effect}Checkbox"]`).closest('.effect-control');
//         checkboxDiv.insertAdjacentElement('afterend', button);
//     }


//     });
// }



function displayEffectButtons() {
    const searchTerm = effectSearchBar.value.toLowerCase();
    
    // Clear existing buttons first
    Array.from(effectControls.children).forEach(child => {
        if (child.tagName !== 'DIV') {
            child.remove();
        }
    });

    // Create buttons for filtered effects
    effects.forEach(effect => {
        const checkbox = document.getElementById(`${effect}Checkbox`);
        if (!checkbox || !checkbox.checked) return;

        const button = document.createElement('button');
        button.className = 'effect-button';
        button.textContent = effect;
        button.dataset.effect = effect;
        button.dataset.active = 'true';
        
        // Check if effect matches search term
        if (searchTerm && !effect.toLowerCase().includes(searchTerm)) {
            button.style.display = 'none';
        }

        button.addEventListener('mouseenter', () => displayEffectImages(effect));
        button.addEventListener('click', () => {
            toggleEffect(button);
            displayEffectImages(effect);
        });

        const checkboxDiv = checkbox.closest('.effect-control');
        checkboxDiv.insertAdjacentElement('afterend', button);
    });
}
function initializeEffectControls() {
    const effectControls = document.getElementById('effectControls');
    
    effects.forEach(effect => {
        const div = document.createElement('div');
        div.className = 'effect-control';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `${effect}Checkbox`;
        checkbox.checked = true;
        
        const label = document.createElement('label');
        label.htmlFor = `${effect}Checkbox`;
        label.textContent = effect;
        
        div.appendChild(checkbox);
        div.appendChild(label);
        effectControls.appendChild(div);
    });
}
async function fastProcessImage(img, existingGeneratedImages = []) {
    processedImages = {};  
    const imageCount = parseInt(imageCountInput.value);
    displayEffectButtons();

    // Initialize generatedImages if not already defined
    if (!generatedImages) {
        generatedImages = [];
    }

    // Clear generatedImages if there are no existing generated images
    if (existingGeneratedImages.length === 0) {
        generatedImages = [];
    }

    // Convert input image if needed
    const processInputImage = async (inputImg) => {
        if (inputImg instanceof HTMLImageElement) {
            return inputImg;
        } else if (typeof inputImg === 'string' && 
                   (inputImg.startsWith('data:image') || inputImg.startsWith('http'))) {
            return await new Promise((resolve, reject) => {
                const tempImg = new Image();
                tempImg.onload = () => resolve(tempImg);
                tempImg.onerror = reject;
                tempImg.src = inputImg;
            });
        } else if (inputImg && inputImg.imageUrl) {
            return await new Promise((resolve, reject) => {
                const tempImg = new Image();
                tempImg.onload = () => resolve(tempImg);
                tempImg.onerror = reject;
                tempImg.src = inputImg.imageUrl;
            });
        }
        throw new Error('Invalid image format');
    };

    // Process a single image with an effect
    const processImageWithEffect = async (sourceImg, effect, value, sourceType, sourceIndex) => {
        const canvas = document.createElement('canvas');
        canvas.width = sourceImg.width;
        canvas.height = sourceImg.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(sourceImg, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        let processedImageData;
        try {
            processedImageData = await applyEffect(effect, imageData, value, selectedRegions);
        } catch (error) {
            console.error(`Error applying effect ${effect}:`, error);
            return null;
        }

        const resultCanvas = document.createElement('canvas');
        resultCanvas.width = sourceImg.width;
        resultCanvas.height = sourceImg.height;
        const resultCtx = resultCanvas.getContext('2d');
        resultCtx.putImageData(processedImageData, 0, 0);

        const processedResult = {
            value: value,
            dataUrl: resultCanvas.toDataURL(),
            sourceType: sourceType,
            sourceIndex: sourceIndex
        };

        // Add to source images for tracking
        sourceImages.push({
            index: value,
            type: `${effect} leg`,
            image: resultCanvas,
            imageUrl: resultCanvas.toDataURL(),
            imageData: processedImageData.data,
            width: processedImageData.width,
            height: processedImageData.height,
            sourceType: sourceType,
            sourceIndex: sourceIndex,
            value: value
        });

        generatedImages.push({
            index: value,
            type: `${effect} leg`,
            image: resultCanvas,
            imageUrl: resultCanvas.toDataURL(),
            imageData: processedImageData.data,
            width: processedImageData.width,
            height: processedImageData.height,
            sourceType: 'original',
            sourceIndex: 0,
            value: value
        });
        
        return processedResult;
    };

    const selectedEffects = effects.filter(effect => 
        document.getElementById(`${effect}Checkbox`).checked
    );

    try {
        
        const processedInputImg = await processInputImage(img);
        
        await Promise.all(selectedEffects.map(async (effect) => {
            processedImages[effect] = [];
            
            // Process original image variations
            const originalPromises = Array(imageCount).fill().map(async (_, i) => {
                const value = getEffectValue(effect, i, imageCount);
                const result = await processImageWithEffect(
                    processedInputImg, 
                    effect, 
                    value, 
                    'original', 
                    0
                );
                if (result) {
                    processedImages[effect].push(result);
                    updateEffectDisplay(effect);
                }
            });

            // Process existing generated images
            const generatedPromises = existingGeneratedImages.map(async (genImg, i) => {
                const processedGenImg = await processInputImage(genImg);
                const value = getEffectValue(effect, i, existingGeneratedImages.length);
                const result = await processImageWithEffect(
                    processedGenImg, 
                    effect, 
                    value, 
                    'generated', 
                    i
                );
                if (result) {
                    processedImages[effect].push(result);
                    updateEffectDisplay(effect);
                }
            });

            await Promise.all([...originalPromises, ...generatedPromises]);
        }));

    } catch (error) {
        console.error('Error in image processing:', error);
    }

    displayProcessedImages();
}

sourceImages = [];

async function processImage(img) {
    processedImages = {};

    const defaultImageCount = parseInt(imageCountInput.value);
    displayEffectButtons();

    // Create a copy of generated images to prevent infinite processing
    const existingGeneratedImages = generatedImages ? [...generatedImages] : [];
    // Clear generated images if processing original image
    if (!existingGeneratedImages.length) {
        generatedImages = [];
    }
  
    for (const effect of effects.filter(effect => document.getElementById(`${effect}Checkbox`).checked)) {
        processedImages[effect] = [];
        // // console.log(`Processing effect: ${effect}`);
        // // console.log(selectedRegions);
        
        // If we have generated images, process each one once
        if (existingGeneratedImages && existingGeneratedImages.length > 0) {
            // // console.log(`Processing ${existingGeneratedImages.length} generated images`);
            
            // Process each generated image
            for (let i = 0; i < existingGeneratedImages.length; i++) {
                try {
                    let processedImage;
                    const generatedImg = existingGeneratedImages[i];
                    // // console.log(selectedRegions);
                    // Convert the generated image to HTMLImageElement
                    if (generatedImg instanceof HTMLImageElement) {
                        processedImage = generatedImg;
                    } else if (typeof generatedImg === 'string' && 
                             (generatedImg.startsWith('data:image') || generatedImg.startsWith('http'))) {
                        
                                // // console.log(selectedRegions);
                                        processedImage = await new Promise((resolve, reject) => {
                            const tempImg = new Image();
                            tempImg.onload = () => resolve(tempImg);
                            tempImg.onerror = reject;
                            tempImg.src = generatedImg;
                        });
                    } else if (generatedImg && generatedImg.imageUrl) {
                        // // console.log(selectedRegions);
                        processedImage = await new Promise((resolve, reject) => {
                            const tempImg = new Image();
                            tempImg.onload = () => resolve(tempImg);
                            tempImg.onerror = reject;
                            tempImg.src = generatedImg.imageUrl;
                        });
                    }

                    if (processedImage) {
                        // Create new canvas and context for this specific generated image
                        const canvas = document.createElement('canvas');
                        canvas.width = processedImage.width;
                        canvas.height = processedImage.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(processedImage, 0, 0);
                        // // console.log(selectedRegions);
                        // Get unique imageData for this generated image
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        // // console.log(selectedRegions)

                        // // console.log(`Processing generated image ${i + 1} with unique imageData`);
                        const value = getEffectValue(effect, i, existingGeneratedImages.length);

                        const processedImageData = await applyEffect(effect, imageData, value, selectedRegions);
                        
                        // Create new canvas for the processed result
                        const resultCanvas = document.createElement('canvas');
                        resultCanvas.width = processedImage.width;
                        resultCanvas.height = processedImage.height;
                        const resultCtx = resultCanvas.getContext('2d');
                        resultCtx.putImageData(processedImageData, 0, 0);
                        // // console.log(selectedRegions);
                        const processedResult = {
                            value: value,
                            dataUrl: resultCanvas.toDataURL(),
                            sourceType: 'generated',
                            sourceIndex: i
                        };
                        
                        processedImages[effect].push(processedResult);
                        // // console.log(selectedRegions);
                        sourceImages.push({
                            index: value,
                            type: `${effect} leg`,
                            image: resultCanvas, // Use the processed canvas
                            imageUrl: resultCanvas.toDataURL(),
                            imageData: processedImageData.data,
                            width: processedImageData.width,
                            height: processedImageData.height,
                            sourceType: 'generated',
                            sourceIndex: i,
                            value: value
                        });
                        // // console.log(selectedRegions);
                        updateEffectDisplay(effect);
                        // // console.log(selectedRegions);
                    }

                    
                } catch (error) {
                    console.error(`Error processing generated image ${i + 1}:`, error);
                }
            }
        } 
        // If no generated images, process original image with variations
        else if (img instanceof HTMLImageElement) {
         

            for (let i = 0; i < defaultImageCount; i++) {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    let value = getEffectValue(effect, i, defaultImageCount);
                    // // console.log(`Processing original image variation ${i + 1}/${defaultImageCount}`);
                    
                    const processedImageData = await applyEffect(effect, imageData, value, selectedRegions);
                    
                    const resultCanvas = document.createElement('canvas');
                    resultCanvas.width = img.width;
                    resultCanvas.height = img.height;
                    const resultCtx = resultCanvas.getContext('2d');
                    // console.log(processedImageData);
                    resultCtx.putImageData(processedImageData, 0, 0);
                    // // console.log(selectedRegions);
                    const processedResult = {
                        value: value,
                        dataUrl: resultCanvas.toDataURL(),
                        sourceType: 'original',
                        sourceIndex: 0
                    };
                    // // console.log(selectedRegions);
                    processedImages[effect].push(processedResult);
                    
                    // Add to generated images for future processing
                    generatedImages.push({
                        index: value,
                        type: `${effect} leg`,
                        image: resultCanvas,
                        imageUrl: resultCanvas.toDataURL(),
                        imageData: processedImageData.data,
                        width: processedImageData.width,
                        height: processedImageData.height,
                        sourceType: 'original',
                        sourceIndex: 0,
                        value: value
                    });
                    // // console.log(selectedRegions);
                    sourceImages.push({
                        index: value,
                        type: `${effect} leg`,
                        image: resultCanvas,
                        imageUrl: resultCanvas.toDataURL(),
                        imageData: processedImageData.data,
                        width: processedImageData.width,
                        height: processedImageData.height,
                        sourceType: 'original',
                        sourceIndex: 0,
                        value: value
                    });
                    // // console.log(selectedRegions);
                    updateEffectDisplay(effect);
                } catch (error) {
                    console.error(`Error processing original image variation ${i + 1}:`, error);
                }
            }
        }
    }
    
    displayProcessedImages();
}


function displayProcessedImages() {
    // resultsContainer.innerHTML = '';
    
    // for (const effect in processedImages) {
    //     if (document.getElementById(`${effect}Checkbox`).checked) {
    //         const images = processedImages[effect];
    //         // Check if images exist and have data
    //         if (images && images.length > 0 && images[0] && images[0].imageData) {
    //             const effectDiv = document.createElement('div');
    //             effectDiv.className = 'effect-results';
                
    //             const effectTitle = document.createElement('h3');
    //             effectTitle.textContent = effect;
    //             effectDiv.appendChild(effectTitle);
                
    //             const canvas = document.createElement('canvas');
    //             canvas.width = images[0].imageData.width;
    //             canvas.height = images[0].imageData.height;
    //             effectDiv.appendChild(canvas);
                
    //             const ctx = canvas.getContext('2d');
    //             let currentFrame = 0;
                
    //             function animate() {
    //                 if (images[currentFrame] && images[currentFrame].imageData) {
    //                     ctx.clearRect(0, 0, canvas.width, canvas.height);
    //                     ctx.putImageData(images[currentFrame].imageData, 0, 0);
    //                     currentFrame = (currentFrame + 1) % images.length;
    //                     setTimeout(animate, 200);
    //                 }
    //             }
                
    //             animate();
    //             resultsContainer.appendChild(effectDiv);
    //         } else {
    //             // console.log(`No valid image data found for effect: ${effect}`);
    //         }
    //     }
    // }

}


// Add the filter effects function
function filterEffects(event) {
    const searchTerm = event.target.value.toLowerCase();
    const effectControls = document.getElementById('effectControls');
    
    effects.forEach(effect => {
        const effectDiv = document.querySelector(`.effect-control:has(#${effect}Checkbox)`);
        const effectButton = document.querySelector(`button[data-effect="${effect}"]`);
        
        if (!effectDiv) return;
        
        if (searchTerm === '') {
            // Show all effects when search is empty
            effectDiv.style.display = '';
            if (effectButton) effectButton.style.display = '';
        } else {
            // Show/hide based on search match
            const matches = effect.toLowerCase().includes(searchTerm);
            effectDiv.style.display = matches ? '' : 'none';
            if (effectButton) effectButton.style.display = matches ? '' : 'none';
        }
    });
}


function convertImageRepresentation(imageRepresentation) {
    return new Promise((resolve, reject) => {
        if (imageRepresentation instanceof HTMLImageElement) {
            resolve(imageRepresentation);
        } else if (typeof imageRepresentation === 'string' && (imageRepresentation.startsWith('data:image') || imageRepresentation.startsWith('http'))) {
            const tempImg = new Image();
            tempImg.onload = () => resolve(tempImg);
            tempImg.onerror = reject;
            tempImg.src = imageRepresentation;
        } else if (imageRepresentation && imageRepresentation.imageUrl) {
            const tempImg = new Image();
            tempImg.onload = () => resolve(tempImg);
            tempImg.onerror = reject;
            tempImg.src = imageRepresentation.imageUrl;
        } else {
            reject(new Error('Invalid image representation'));
        }
    });
}

function processImageWithMethod(processingMethod) {

    if (!useCredits(1)) {
        return; // Stop if not enough credits
    }
    
    const file = imageUpload.files[0];
    if (file) {
        const objectUrl = URL.createObjectURL(file);
        const img = new Image();
        img.onload = function() {
            URL.revokeObjectURL(objectUrl);
            processingMethod(img);
        }
        img.onerror = function() {
            console.error('Failed to load image');
            alert('Failed to load the selected image.');
        }
        img.src = objectUrl;
    } else if (generatedImages && generatedImages.length > 0) {
        // If no uploaded image but generated images exist
        processingMethod(generatedImages[0]);
    } else {
        alert('Please select an image first.');
    }
}

function toggleEffect(button) {
    button.dataset.active = button.dataset.active === 'true' ? 'false' : 'true';
    button.classList.toggle('inactive');
}

function displayEffectImages(effect) {
    resultsContainer.innerHTML = '';

    if (document.getElementById(`${effect}Checkbox`).checked) {
        const images = processedImages[effect];
        // console.log(processedImages);
        if (images && images.length > 0) {
            // Create single wrapper for animation
            const wrapper = document.createElement('div');
            wrapper.className = 'canvas-wrapper';
            
            // Create single image element that will be updated
            const img = new Image();
            img.id = `${effect}-image`;
            img.className = 'processed-image';
            wrapper.appendChild(img);
            resultsContainer.appendChild(wrapper);
            
            // Animation variables
            let currentFrame = 0;
            
            function animate() {
                // Update image source to current frame
                img.src = images[currentFrame].dataUrl;
                // Move to next frame
                currentFrame = (currentFrame + 1) % images.length;
                // Continue animation after 200ms
                setTimeout(animate, 200);
            }
            
            animate();

        } else {
            resultsContainer.textContent = 'Processing...';
        }
    } else {
        resultsContainer.textContent = 'Effect not selected';
    }
}

function getEffectValue(effect, index, count) {
    const t = index / (count - 1);
    switch(effect) {
        case 'brightness': return Math.floor(t * 510) - 255;
        case 'hue': return Math.floor(t * 360);
        case 'saturation': return t * 2;
        case 'vintage': case 'ink': case 'vibrance': case 'denoise': case 'hexagonalPixelate': case 'invert':
        case 'perspectiveTilt': case 'perspectiveSqueeze': case 'perspectiveCurve': case 'perspectiveFisheye':
        case 'perspectiveRotate': case 'perspectiveSkew': case 'perspectiveWarp': case 'perspectiveZoom':
        case 'perspectiveTunnel': case 'perspectiveSphere': case 'perspectiveCylinder': case 'perspectiveRipple':
        case 'perspectiveVortex': case 'perspectiveFold': case 'perspectivePixelate': case 'perspectiveEmboss':
        case 'perspectiveMosaic': case 'perspectiveOilPainting': case 'perspectivePosterize':
            return t;
        case 'bulgePinch': return [t, t * 2 - 1];
        case 'swirl': return (t - 0.5) * 10;
        case 'lensBlur': case 'triangularBlur': return t * 50;
        case 'tiltShiftBlur': case 'zoomBlur': return [t, 1-t];
        case 'edgeWork': return t * 10 + 1;
        case 'dotScreen': case 'colorHalftone': return t * 10;
        case 'perspectiveTwist': return t * Math.PI * 2;
        case 'perspective': return [t, 1-t, t, 1-t];
        case 'kaleidoscope': return Math.floor(t * 16) + 2;
        case 'wavyDistortion': return [t * 50, (1-t) * 50, t * Math.PI * 2];
        case 'blockDissolve': return Math.floor(t * 20) + 1;
        case 'rgbShift': return [t * 10, (1-t) * 10, t * 10];
        case 'chromaticAberration': return t * 20;
        case 'droste': return [t * 5, (1-t) * 5, t * Math.PI * 2];
        case 'running1': return [
                t * 10,           
                (1-t) * 1,        
                t * Math.PI * 2,  // Leg swing
                (1-t) * Math.PI   // Arm swing
            ];
        case 'running2': return [
            t, // time
            0.5 + t * 1.5, // speed
            0.2 + t * 0.8 // intensity
        ];
        case 'running3': return t;
        case 'running4': return t;
        case 'running5': return t; 
        case 'running6': return t;
        case 'running7': return t;
        case 'running8': return t;
        case 'running9': return t; 
        case 'running10': return t;
        case 'running11': return t;
        case 'running12': return t; 
        case 'running13': return t; 
        default: return t;
    }
}


        function generateBrightnessVariations() {
            const imageCount = parseInt(document.getElementById('imageCount').value);
            const maxBrightness = parseInt(document.getElementById('brightness').value);
            
            const value1 = parseInt(document.getElementById('value1').value);
            const value2 = parseInt(document.getElementById('value2').value);
            const value3 = parseInt(document.getElementById('value3').value);
            const value4 = parseInt(document.getElementById('value4').value);
            const value5 = parseInt(document.getElementById('value5').value);

            const worker = new Worker('js/brightnessWorker.js');
            worker.postMessage({
                imageData: originalImageData,  // Use originalImageData instead of canvas data
                selectedRegions: selectedRegions,
                imageCount: imageCount,
                maxBrightness: maxBrightness,
                value1: value1,
                value2: value2,
                value3: value3,
                value4: value4,

                value5: value5,
                clickedPoints: clickedPoints,
                lines: lines // Add lines array
            });

            worker.onmessage = function(e) {
                // displaySegmentedImages(e.data.segmentedImages);
                if (e.data.error) {
                    reject(new Error(`Error in ${effect} worker: ${e.data.error}`));
                } else {
                    // console.log('e.data.segmentedImages :>> ', e.data.segmentedImages);
                    resolve(e.data.segmentedImages[0]); // Updated to match worker response format
                }
            };
        }

        function displaySegmentedImages(segmentedImages) {
            const container = document.getElementById('generatedImages');
            if (container) {
                container.innerHTML = '';

                const canvas = document.createElement('canvas');
                canvas.width = segmentedImages[0].width;
                canvas.height = segmentedImages[0].height;
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                let currentFrame = 0;

                function animate() {
                    ctx.putImageData(segmentedImages[currentFrame], 0, 0);
                    currentFrame = (currentFrame + 1) % segmentedImages.length;
                    setTimeout(animate, 200); 
                }

                animate();
            } else {
                console.error("Element with ID 'generatedImages' not found.");
            }
        }

    


        
const BODY_PARTS = {
    'left_face': { name: 'Left Face', description: 'Left side of the face' },
    'right_face': { name: 'Right Face', description: 'Right side of the face' },
    'left_upper_arm_front': { name: 'Left Upper Arm (Front)', description: 'Front of left upper arm' },
    'left_upper_arm_back': { name: 'Left Upper Arm (Back)', description: 'Back of left upper arm' },
    'right_upper_arm_front': { name: 'Right Upper Arm (Front)', description: 'Front of right upper arm' },
    'right_upper_arm_back': { name: 'Right Upper Arm (Back)', description: 'Back of right upper arm' },
    'left_lower_arm_front': { name: 'Left Lower Arm (Front)', description: 'Front of left forearm' },
    'left_lower_arm_back': { name: 'Left Lower Arm (Back)', description: 'Back of left forearm' },
    'right_lower_arm_front': { name: 'Right Lower Arm (Front)', description: 'Front of right forearm' },
    'right_lower_arm_back': { name: 'Right Lower Arm (Back)', description: 'Back of right forearm' },
    'left_hand': { name: 'Left Hand', description: 'Left hand' },
    'right_hand': { name: 'Right Hand', description: 'Right hand' },
    'torso_front': { name: 'Torso Front', description: 'Front of the torso' },
    'torso_back': { name: 'Torso Back', description: 'Back of the torso' },
    'left_upper_leg_front': { name: 'Left Upper Leg (Front)', description: 'Front of left thigh' },
    'left_upper_leg_back': { name: 'Left Upper Leg (Back)', description: 'Back of left thigh' },
    'right_upper_leg_front': { name: 'Right Upper Leg (Front)', description: 'Front of right thigh' },
    'right_upper_leg_back': { name: 'Right Upper Leg (Back)', description: 'Back of right thigh' },
    'left_lower_leg_front': { name: 'Left Lower Leg (Front)', description: 'Front of left calf' },
    'left_lower_leg_back': { name: 'Left Lower Leg (Back)', description: 'Back of left calf' },
    'right_lower_leg_front': { name: 'Right Lower Leg (Front)', description: 'Front of right calf' },
    'right_lower_leg_back': { name: 'Right Lower Leg (Back)', description: 'Back of right calf' },
    'left_foot': { name: 'Left Foot', description: 'Left foot' },
    'right_foot': { name: 'Right Foot', description: 'Right foot' },
    'left_upper_foot': { name: 'Left Upper Foot', description: 'Upper part of left foot' },
    'left_lower_foot': { name: 'Left Lower Foot', description: 'Lower part of left foot' },
    'right_upper_foot': { name: 'Right Upper Foot', description: 'Upper part of right foot' },
    'right_lower_foot': { name: 'Right Lower Foot', description: 'Lower part of right foot' }
};
