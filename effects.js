const effects = 
[
    "lrsqueeze",
    "persanticlockrotate",
    "dancechest",
    "snake",
    "legdance",
    "randomdance",
    "moverightside",
    "movingrightsideplus",
    "rightleft",
    "downzeroup",
    "tinyshoulder",
    "tinyshouldermovements",
    "downzeroupdown",
    "leftrightdance",
    "yogaleft",
    "hrithikdance",
    "curvedance",
    "angrybirds",
    "upjump",
    "downzoom",
    "updown",
    "jumpleft",
    "explosion",
    'explosion1',
    "firework",
    "leftbottomzerorighttop",
    "rainbow",
    "zoommove",
    "upzoomdownsmall",
    "neonblue",
    "bothsideclone",
    "bulgepinchreal",
    "gravitybounce",
    "squeezex2",
    "squeezey2",
    "createround",
    "topviewwaterripple",
    "fullleft",
    "clock",
    "butterfly1",
    "twist",
    "tiltsmall",
    "fullupchange",
    "tattoo",
    "lipshape",
    "reallips",
    "parallaxselectedregion",
    "leftVR",
    "leftVR1",
    "rotatey",
    "rotatey3d",
    "leftrightVR",
    "fullimageextend",
    "stonewriting",
    "downchange",
    "sideextension",
    "bodytoashes",
    "whiteline",
    "leftdownzerorightdown",
    "projectile",
    "projectile1",
    'fanceiling',
    'fanceiling1',
    'fanceiling2',
    'fanceilingfast',
    'fanceilingfast1',
    "projectile2",
    "projectile3",
    "projectiletopleft",
    "reverseclock",
    "lefttoprightcircle",
    "infinite",
    "spongeball",
    "downelongate",
    "standing",
    "rightsidesitting",
    "rightsidesitting1",
    "running2",
    "running3",
    "running4",
    "running5",
    "running6",
    "running7",
    "running8",
    "running9",
    "running10",
    "running11",
    "running12",
    "running14",
    "running15",
    "running16",
    "running17",
    "running18",
    "running19",
    "running20",
    "running21",
    "running22",
    "running23",
    "running24",
    "running25",
    "running26",
    "running27",
     "running28",
    "running29",
    "running30",
    "running31",
    "running32",
    "running33",
    "running34",
    "running35",
    "running36",
    "running37",
    "backgroundpredict2",
    "backgroundpredict3",
    "backgroundpredict4",
    "backgroundpredict5",
    "backgroundpredict6",
    "backgroundpredict7",
    "backgroundpredict",
    "background",
    "BHUE",
    "colorchange",
    "blockDissolve1",
    "blockDissolve",
    "bottom10",
    "up10",
    "bottomleft",
    "fullright",
    "bottomright",
    "upright",
    "upleft",
    "brightness1",
    "brightness3",
    "brightness",
    "bulgepinch101",
    "bulgepinch103",
    "bulgepinch104",
    "bulgepinch102",
    "scale",
    "bulgepinch10",
    "bulgePinch1",
    "bulgePinch2",
    "bulgePinch3",
    "bulgePinch4",
    "colorHalfTone",
    "colorUtils",
    "replaceimage1",
    "denoise1",
    "depthAnd3DEffect",
    "depthEstimation",
    "depthMap",
    "dotScreen",
    "down10",
    "downleft10",
    "downright10",
    "droste10",
    "droste11",
    "edgework101",
    "edgework102",
    "edgework10",
    "faceindexmovement1",
    "hexagonalPixelate",
    "hue10",
    "hue1",
    "hue",
    'reallips1',
    'reallips2',
    'reallips3',
    'reallips4',
    'reallips5',
    'reallips6',
    'reallips7',
    'reallips8',
    "indexlips",
    "indexlipsqueeze",
    "indexlipscartoon",
    "outline",
    "ink1",
    "invert",
    "jump",
    "kaleidoscopefullimage",
    "kaleidoscope",
    "left10",
    "right10",
    "lipsync1",
    "lensBlur",
    "lipsync",
    "lipsync10",
    "parallax3d",
    "parallaxdown10",
    "parallaxdownsmall10",
    "parallaxleft10",
    "parallaxleftlarge10",
    "border",
    "parallaxVR10",
    "parallaxleftsmall10",
    "parallaxVR101",
    "perspectiveCubeMap",
    "perspectiveVRcubemap",
    "rotatecentre",
    "perspectiveVRcubemap1",
    "perspectiveVRcubemap2",
    "perspectiveCurve",
    "fullimagesidebyside",
    "perspectiveCurvecopy3",
    "cylinder",
    "perspectiveCylinder",
    "perspectiveEmboss",
    "perspectiveextend",
    "perspectiveField",
    "perspectiveFieldselectedregion",
    "perspectiveFisheye",
    "perspectiveFold",
    "perspectivestepup",
    "perspectiverotate1",
    "perspectiveKaleidoscope",
    "perspectiveMosaic",
    "perspectivePinch",
    "perspectivePinch1",
    "perspectivePosterize",
    "perspectiveRotate",
    "perspectiveSkew",
    "perspectiveSphere",
    "perspectivesqueeze1",
    "perspectiveSqueeze",
    "perspectiveTilt1",
    "perspectiveTilt2",
    "zoom",
    "perspectiveTunnel",
    "perspectiveTwist",
    "perspectiveTwist1",
    "perspectiveVortex",
    "bookfold",
    "perspectiveWarp",
    "perspectiveWave",
    "perspectiveWrap",
    "perspectiveZoom",
    "perspectiveZoom1",
    "posedetection",
    "pp2",
    "mesh",
    "pp3",
    "pp4",
    "pp5",
    "randompic",
    "removebg",
    
    "rotatebottomleftccw",
    "rotatebottomleftcw",
    "rotatebottomleftvariable",
    "rotatebottomleft",
    "projectileleft",
    "rotatebottomrightccw",
    "projectileleft1",
    "rotatebottomrightcw",
    "rotatebottomright",
    "rotatetopleftccw",
    "rotatetopleftcw",
    "rotatetopleft",
    "rotatetoprightccw",
    "rotatetoprightcw",
    "3d",
    "runninganti",
    "balloon",
    "runningleg2",
    "runningleg3",
    "runningleg4",
    "oscillate",
    "runningleg",
    "running",
    "saturation10",
    "segmentation10",
    "segmentation11",
    "segmentation12",
    "segmentimageselectedregion1",
    "segmentimageselectedregion",
    "sittinganti",
    "sitting",
    "smooth-edges",
    "smoothedgelight",
    "smoothedges2",
    "squeeze1",
    "widen",
    "squeeze2",
    "squeeze3",
    "squeezex1",
    "squeezex",
    "squeezey1",
    "squeezey",
    "swirl",
    "threeDE",
    "droste",
    "running1"
]


const animationEffects = [
    // 'perspectiveTilt', 'perspectiveSqueeze', 'perspectiveCurve', 'perspectiveTwist',
    // 'perspectiveFisheye', 'perspective', 'perspectiveRotate', 'perspectiveSkew',
    // 'perspectiveWarp', 'perspectiveZoom', 'perspectiveTunnel', 'perspectiveSphere',
    // 'perspectiveCylinder', 'perspectiveRipple', 'perspectiveVortex', 'perspectiveFold',
    // 'perspectivePixelate', 'perspectiveEmboss', 'perspectiveMosaic',
    // 'perspectiveOilPainting', 'perspectivePosterize'
];

function toggleAnimationEffects() {
    const animationCheckbox = document.getElementById('animationCheckbox');
    const animationCheckboxLabel = document.getElementById('animationCheckboxLabel');
    const isChecked = animationCheckbox.checked;

    // Update the label text based on the checkbox state
    animationCheckboxLabel.textContent = isChecked ? 'Unselect All' : 'Select All';

    // Toggle all animation effects
    animationEffects.forEach(effect => {
        const checkbox = document.getElementById(effect + 'Checkbox');
        console.log(checkbox); // Should log the checkbox element

        if (checkbox) {
            checkbox.checked = isChecked;
        }
    });

    updateMasterCheckbox();
}

// function toggleAllEffects() {
//     const isChecked = masterCheckbox.checked;
//     effects.forEach(effect => {
//         if (!animationEffects.includes(effect)) {
//             document.getElementById(effect + 'Checkbox').checked = isChecked;
//         }
//     });
// }

function toggleAllEffects() {
    const isChecked = masterCheckbox.checked;
    const searchTerm = effectSearchBar.value.toLowerCase();
    
    effects.forEach(effect => {
        if (!animationEffects.includes(effect)) {
            const checkbox = document.getElementById(effect + 'Checkbox');
            if (checkbox) {
                // Only toggle checkboxes for visible effects (matching search)
                const effectDiv = checkbox.closest('.effect-control');
                if (effectDiv.style.display !== 'none') {
                    checkbox.checked = isChecked;
                }
            }
        }
    });
    
    // Update displayed buttons after toggling checkboxes
    displayEffectButtons();
}

function updateMasterCheckbox() {
    const effectCheckboxes = effects.filter(effect => !animationEffects.includes(effect));
    const allChecked = effectCheckboxes.every(effect => document.getElementById(effect + 'Checkbox').checked);
    const anyChecked = effectCheckboxes.some(effect => document.getElementById(effect + 'Checkbox').checked);
    masterCheckbox.checked = allChecked;
    masterCheckbox.indeterminate = anyChecked && !allChecked;
}

function updateEffectDisplay(effect) {
    const effectButton = document.querySelector(`.effect-button[data-effect="${effect}"]`);
    if (effectButton) effectButton.classList.add('processed');
}

let startTime = 0;
let endTime = 0;
let timerInterval;

function startTimer() {
    startTime = Date.now();
    updateTimer();
    timerInterval = setInterval(updateTimer, 10); // Update every 10ms for smoother display
}

function endTimer() {
    endTime = Date.now();
    clearInterval(timerInterval);
    updateTimer();
}

function updateTimer() {
    const currentTime = endTime || Date.now();
    const elapsedTime = currentTime - startTime;
    
    // Convert to minutes, seconds, and milliseconds
    const minutes = Math.floor(elapsedTime / 60000);
    const seconds = Math.floor((elapsedTime % 60000) / 1000);
    const milliseconds = elapsedTime % 1000;

    // Format the time as MM:SS:mmm
    const displayTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
    
    // Update the timer display
    document.getElementById('timer').textContent = displayTime;
}

// Reset function if needed
function resetTimer() {
    clearInterval(timerInterval);
    startTime = 0;
    endTime = 0;
    document.getElementById('timer').textContent = '00:00:000';
}


function applyEffect(effect, imageData, value, selectedRegions) {
    const startTime = Date.now(); // Record start time when posting to worker
    
    return new Promise((resolve, reject) => {
        if (!workers[effect]) {
            reject(new Error(`Worker for effect ${effect} not found`));
            return;
        }

        workers[effect].onmessage = function(e) {
            const endTime = Date.now(); // Record end time when receiving response
            const executionTime = endTime - startTime;
            
            // Update timer display
            const timerElement = document.getElementById('timer');
            if (timerElement) {
                // Convert to minutes, seconds, milliseconds
                const minutes = Math.floor(executionTime / 60000);
                const seconds = Math.floor((executionTime % 60000) / 1000);
                const milliseconds = executionTime % 1000;
                
                // Format as MM:SS:mmm
                timerElement.textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
            }

            if (e.data.error) {
                reject(new Error(`Error in ${effect} worker: ${e.data.error}`));
            } else {
                // console.log('e.data.segmentedImages :>> ', e.data.segmentedImages);
                // console.log(e.data);
                resolve(e.data.segmentedImages[0]); // Updated to match worker response format
            }
        };

        workers[effect].onerror = function(error) {
            const endTime = Date.now();
            const executionTime = endTime - startTime;
            
            // Update timer even in case of error
            const timerElement = document.getElementById('timer');
            if (timerElement) {
                const minutes = Math.floor(executionTime / 60000);
                const seconds = Math.floor((executionTime % 60000) / 1000);
                const milliseconds = executionTime % 1000;
                timerElement.textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
            }
            
            reject(new Error(`Error in ${effect} worker: ${error.message}`));
        };

        // Send data to the worker
        workers[effect].postMessage({
            imageData: imageData,
            value: value,
            selectedRegions: selectedRegions
        });
    });
}


// function displayEffectButtons() {
//     const searchTerm = effectSearchBar.value.toLowerCase();
    
//     // Clear existing buttons first
//     Array.from(effectControls.children).forEach(child => {
//         if (child.tagName !== 'DIV') {
//             child.remove();
//         }
//     });

//     // Create buttons for filtered effects
//     effects.forEach(effect => {
//         const checkbox = document.getElementById(`${effect}Checkbox`);
//         if (!checkbox || !checkbox.checked) return;

//         const button = document.createElement('button');
//         button.className = 'effect-button';
//         button.textContent = effect;
//         button.dataset.effect = effect;
//         button.dataset.active = 'true';
        
//         // Check if effect matches search term
//         if (searchTerm && !effect.toLowerCase().includes(searchTerm)) {
//             button.style.display = 'none';
//         }

//         button.addEventListener('mouseenter', () => displayEffectImages(effect));
//         button.addEventListener('click', () => {
//             toggleEffect(button);
//             displayEffectImages(effect);
//         });

//         const checkboxDiv = checkbox.closest('.effect-control');
//         checkboxDiv.insertAdjacentElement('afterend', button);
//     });
// }


function displayEffectButtons() {
    const searchTerm = effectSearchBar.value.toLowerCase();
    
    // Clear existing buttons first
    Array.from(effectControls.children).forEach(child => {
        if (child.tagName !== 'DIV') {
            child.remove();
        }
    });
    
    // Create buttons for filtered effects
    effects.forEach(effect => {
        const checkbox = document.getElementById(`${effect}Checkbox`);
        if (!checkbox) return;
        
        // Hide the checkbox and label
        const checkboxContainer = checkbox.parentElement;
        if (checkboxContainer) {
            const label = checkboxContainer.querySelector('label');
            if (label) label.style.display = 'none';
            checkbox.style.display = 'none';
        }
        
        const button = document.createElement('button');
        button.className = 'effect-button';
        button.textContent = effect;
        button.dataset.effect = effect;
        button.dataset.active = 'true';
        
        // Check if effect matches search term
        if (searchTerm && !effect.toLowerCase().includes(searchTerm)) {
            button.style.display = 'none';
        }
        
        button.addEventListener('mouseenter', () => displayEffectImages(effect));
        button.addEventListener('click', () => {
            toggleEffect(button);
            displayEffectImages(effect);
        });
        
        const checkboxDiv = checkbox.closest('.effect-control');
        checkboxDiv.insertAdjacentElement('afterend', button);
    });
}

function initializeEffectControls() {
    const effectControls = document.getElementById('effectControls');
    
    effects.forEach(effect => {
        const div = document.createElement('div');
        div.className = 'effect-control';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `${effect}Checkbox`;
        checkbox.checked = true;
        
        const label = document.createElement('label');
        label.htmlFor = `${effect}Checkbox`;
        label.textContent = effect;
        
        div.appendChild(checkbox);
        div.appendChild(label);
        effectControls.appendChild(div);
    });
}

async function fastProcessImage(img, existingGeneratedImages = []) {
    processedImages = {};  
    const imageCount = parseInt(imageCountInput.value);
    displayEffectButtons();

    // Initialize generatedImages if not already defined
    if (!generatedImages) {
        generatedImages = [];
    }

    // Clear generatedImages if there are no existing generated images
    if (existingGeneratedImages.length === 0) {
        generatedImages = [];
    }

    // Convert input image if needed
    const processInputImage = async (inputImg) => {
        if (inputImg instanceof HTMLImageElement) {
            return inputImg;
        } else if (typeof inputImg === 'string' && 
                   (inputImg.startsWith('data:image') || inputImg.startsWith('http'))) {
            return await new Promise((resolve, reject) => {
                const tempImg = new Image();
                tempImg.onload = () => resolve(tempImg);
                tempImg.onerror = reject;
                tempImg.src = inputImg;
            });
        } else if (inputImg && inputImg.imageUrl) {
            return await new Promise((resolve, reject) => {
                const tempImg = new Image();
                tempImg.onload = () => resolve(tempImg);
                tempImg.onerror = reject;
                tempImg.src = inputImg.imageUrl;
            });
        }
        throw new Error('Invalid image format');
    };

    // Process a single image with an effect
    const processImageWithEffect = async (sourceImg, effect, value, sourceType, sourceIndex) => {
        const canvas = document.createElement('canvas');
        canvas.width = sourceImg.width;
        canvas.height = sourceImg.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(sourceImg, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        let processedImageData;
        try {
            processedImageData = await applyEffect(effect, imageData, value, selectedRegions);
        } catch (error) {
            console.error(`Error applying effect ${effect}:`, error);
            return null;
        }

        const resultCanvas = document.createElement('canvas');
        resultCanvas.width = sourceImg.width;
        resultCanvas.height = sourceImg.height;
        const resultCtx = resultCanvas.getContext('2d');
        resultCtx.putImageData(processedImageData, 0, 0);

        const processedResult = {
            value: value,
            dataUrl: resultCanvas.toDataURL(),
            sourceType: sourceType,
            sourceIndex: sourceIndex
        };

        // Add to source images for tracking
        sourceImages.push({
            index: value,
            type: `${effect} leg`,
            image: resultCanvas,
            imageUrl: resultCanvas.toDataURL(),
            imageData: processedImageData.data,
            width: processedImageData.width,
            height: processedImageData.height,
            sourceType: sourceType,
            sourceIndex: sourceIndex,
            value: value
        });

        generatedImages.push({
            index: value,
            type: `${effect} leg`,
            image: resultCanvas,
            imageUrl: resultCanvas.toDataURL(),
            imageData: processedImageData.data,
            width: processedImageData.width,
            height: processedImageData.height,
            sourceType: 'original',
            sourceIndex: 0,
            value: value
        });
        
        return processedResult;
    };

    const selectedEffects = effects.filter(effect => 
        document.getElementById(`${effect}Checkbox`).checked
    );

    try {
        
        const processedInputImg = await processInputImage(img);
        
        await Promise.all(selectedEffects.map(async (effect) => {
            processedImages[effect] = [];
            
            // Process original image variations
            const originalPromises = Array(imageCount).fill().map(async (_, i) => {
                const value = getEffectValue(effect, i, imageCount);
                const result = await processImageWithEffect(
                    processedInputImg, 
                    effect, 
                    value, 
                    'original', 
                    0
                );
                if (result) {
                    processedImages[effect].push(result);
                    updateEffectDisplay(effect);
                }
            });

            // Process existing generated images
            const generatedPromises = existingGeneratedImages.map(async (genImg, i) => {
                const processedGenImg = await processInputImage(genImg);
                const value = getEffectValue(effect, i, existingGeneratedImages.length);
                const result = await processImageWithEffect(
                    processedGenImg, 
                    effect, 
                    value, 
                    'generated', 
                    i
                );
                if (result) {
                    processedImages[effect].push(result);
                    updateEffectDisplay(effect);
                }
            });

            await Promise.all([...originalPromises, ...generatedPromises]);
        }));

    } catch (error) {
        console.error('Error in image processing:', error);
    }

    displayProcessedImages();
}

sourceImages = [];

function displayFinishedAnimations() {
    resultsContainer.innerHTML = ''; // Clear existing content

    // Iterate through all effects
    effects.forEach(effect => {
        if (animationStatus[effect] && processedImages[effect]?.length > 0) {
            // Create a container for the effect
            const container = document.createElement('div');
            container.className = 'effect-container';

            // Add a label for the effect
            const label = document.createElement('div');
            label.className = 'effect-label';
            label.textContent = effect; // Use the effect name as the label
            container.appendChild(label);

            // Create a wrapper for the animation
            const wrapper = document.createElement('div');
            wrapper.className = 'canvas-wrapper';

            // Create the image element for the animation
            const img = new Image();
            img.id = `${effect}-image`;
            img.className = 'processed-image';

            // Add the image to the wrapper
            wrapper.appendChild(img);

            // Add a download icon
            const downloadIcon = document.createElement('div');
            downloadIcon.className = 'download-icon';
            downloadIcon.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-download">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7 10 12 15 17 10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
            `;


            const shareIcon = document.createElement('div');
            shareIcon.className = 'share-icon';
            shareIcon.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-share-2">
                    <circle cx="18" cy="5" r="3"/>
                    <circle cx="6" cy="12" r="3"/>
                    <circle cx="18" cy="19" r="3"/>
                    <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
                    <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
                </svg>
            `;


            // Add click handler for download icon
            downloadIcon.addEventListener('click', async () => {
                const originalContent = downloadIcon.innerHTML;
                downloadIcon.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-loader-2 animate-spin">
                        <path d="M21 12a9 9 0 1 1-6.219-8.56"/>
                    </svg>
                `;

                try {
                    // Load the logo
                    const logo = await new Promise((resolve, reject) => {
                        const logoImg = new Image();
                        logoImg.crossOrigin = "anonymous";
                        logoImg.onload = () => resolve(logoImg);
                        logoImg.onerror = reject;
                        logoImg.src = 'logo1.jpg';
                    });

                    const gif = new GIF({
                        workers: 2,
                        quality: 10,
                        width: img.naturalWidth || 400,
                        height: img.naturalHeight || 300,
                        background: '#FFFFFF'
                    });

                    // Load all images first
                    const loadedImages = await Promise.all(processedImages[effect].map(imageData => {
                        return new Promise((resolve) => {
                            const tempImg = new Image();
                            tempImg.onload = () => resolve(tempImg);
                            tempImg.src = imageData.dataUrl;
                        });
                    }));

                    // Add frames to the GIF with logo
                    loadedImages.forEach(loadedImg => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        canvas.width = loadedImg.width;
                        canvas.height = loadedImg.height;
                        
                        // Fill canvas with white background first
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);

                        // Draw original image
                        ctx.drawImage(loadedImg, 0, 0);

                        // Calculate logo size and position
                        const logoSize = {
                            width: loadedImg.width * 0.1,
                            height: loadedImg.height * 0.05
                        };

                        const logoPosition = {
                            x: canvas.width - logoSize.width - 10,
                            y: canvas.height - logoSize.height - 10
                        };

                        // Draw the logo
                        ctx.drawImage(
                            logo,
                            logoPosition.x,
                            logoPosition.y,
                            logoSize.width,
                            logoSize.height
                        );

                        // Add the frame to the GIF
                        gif.addFrame(canvas, { delay: 200 });
                    });

                    // Render the GIF
                    gif.on('finished', (blob) => {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${effect}-animation.gif`;
                        document.body.appendChild(a);
                        a.click();

                        setTimeout(() => {
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        }, 100);

                        downloadIcon.innerHTML = originalContent;
                    });

                    gif.render();
                } catch (error) {
                    console.error('Error creating GIF:', error);
                    downloadIcon.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-alert-circle">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="12" y1="8" x2="12" y2="12"/>
                            <line x1="12" y1="16" x2="12.01" y2="16"/>
                        </svg>
                    `;
                    setTimeout(() => {
                        downloadIcon.innerHTML = originalContent;
                    }, 2000);
                }
            });


           
         
            // Add a loading state variable
let isGenerating = false;

let isSharing = false; // Track if a share operation is in progress

shareIcon.addEventListener('click', async (event) => {
  // Prevent multiple clicks while sharing
  if (isSharing) {
    console.log('A share operation is already in progress.');
    return;
  }

  try {
    isSharing = true; // Set sharing state to true
    shareIcon.disabled = true; // Disable the share button
    shareIcon.textContent = 'Generating...'; // Update UI to indicate loading

    // Load the watermark logo
    const logo = await loadWatermarkLogo('logo1.jpg');

    // Initialize GIF
    const gif = new GIF({
      workers: 2,
      quality: 10,
      width: img.naturalWidth || 400,
      height: img.naturalHeight || 300,
      background: '#FFFFFF'
    });

    // Load all processed images
    const loadedImages = await Promise.all(
      processedImages[effect].map(imageData => loadImage(imageData.dataUrl))
    );

    // Process frames and add watermark
    loadedImages.forEach(loadedImg => {
      const canvas = createWatermarkedFrame(loadedImg, logo);
      gif.addFrame(canvas, { delay: 200 });
    });

    // Render the GIF
    const gifPromise = new Promise((resolve, reject) => {
      gif.on('finished', resolve);
      gif.on('error', reject);
    });

    gif.render();

    // Wait for the GIF to finish rendering
    const blob = await gifPromise;
    const file = new File([blob], `${effect}-animation.gif`, { type: 'image/gif' });

    // Prepare share data
    const shareData = {
      title: 'Check out this animation!',
      text: `Created using Imaginea. Visit ${window.location.href} for more.`,
      files: [file]
    };

    // Check if sharing is supported and allowed
    if (navigator.share && navigator.canShare(shareData)) {
      await navigator.share(shareData);
    } else {
      // Fallback: Copy link to clipboard
      await navigator.clipboard.writeText(window.location.href);
      alert('Link copied to clipboard!');
    }

  } catch (error) {
    console.error('Error sharing GIF:', error);

    // Handle specific errors
    if (error.name === 'NotAllowedError') {
      alert('Sharing canceled.');
    } else if (error.name === 'AbortError') {
      alert('Sharing was aborted.');
    } else {
      alert('Error sharing. Please try again.');
    }
  } finally {
    // Reset UI state
    isSharing = false;
    shareIcon.disabled = false;
    shareIcon.textContent = 'Share'; // Reset to original state
  }
});



    async function loadWatermarkLogo(logoPath) {
        return new Promise((resolve, reject) => {
        const logo = new Image();
        logo.crossOrigin = "anonymous";
        logo.onload = () => resolve(logo);
        logo.onerror = (error) => reject(new Error(`Failed to load logo: ${error.message}`));
        logo.src = logoPath;
        });
    }

  async function loadImage(dataUrl) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = (error) => reject(new Error(`Failed to load image: ${error.message}`));
      img.src = dataUrl;
    });
  }
  

  function createWatermarkedFrame(image, logo) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
  
    canvas.width = image.width;
    canvas.height = image.height;
  
    // Fill canvas with white background
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  
    // Draw the original image
    ctx.drawImage(image, 0, 0);
  
    // Calculate logo size and position
    const logoSize = {
      width: image.width * 0.1,
      height: image.height * 0.05
    };
  
    const logoPosition = {
      x: canvas.width - logoSize.width - 10,
      y: canvas.height - logoSize.height - 10
    };
  
    // Draw the logo
    ctx.drawImage(logo, logoPosition.x, logoPosition.y, logoSize.width, logoSize.height);
  
    return canvas;
  }

              // Helper Functions
              
              function createWatermarkedFrame(image, logo) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas dimensions
                canvas.width = image.width;
                canvas.height = image.height;
                
                // Draw white background
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw the main image
                ctx.drawImage(image, 0, 0);
                
                // Calculate logo dimensions and position
                const logoSize = {
                  width: image.width * 0.1,
                  height: image.height * 0.05
                };
                const logoPosition = {
                  x: canvas.width - logoSize.width - 10,
                  y: canvas.height - logoSize.height - 10
                };
                
                // Draw the logo
                ctx.drawImage(logo, logoPosition.x, logoPosition.y, logoSize.width, logoSize.height);
                
                return canvas;
              }
              
              async function createGifFile(blob, effect) {
                return new File([blob], `${effect}-animation.gif`, { type: 'image/gif' });
              }
              
              async function shareGifContent(file) {
                const shareData = {
                  title: 'Check out this animation!',
                  text: `Created using Imaginea. Visit ${window.location.href} for more.`,
                  files: [file]
                };
              
                if (navigator.share && navigator.canShare(shareData)) {
                  await navigator.share(shareData);
                } else {
                  // Fallback to clipboard
                  await navigator.clipboard.writeText(window.location.href);
                  alert('Link copied to clipboard!');
                }
              }
              
              function handleError(error) {
                console.error('Error sharing GIF:', error);
                alert('Sharing failed. Please try again.');
              }


            wrapper.appendChild(downloadIcon);
            wrapper.appendChild(shareIcon);    

            // Add the wrapper to the container
            container.appendChild(wrapper);

            // Add the container to the results
            resultsContainer.appendChild(container);

            // Animate the images
            let currentFrame = 0;
            function animate() {
                img.src = processedImages[effect][currentFrame].dataUrl;
                currentFrame = (currentFrame + 1) % processedImages[effect].length;
                setTimeout(animate, 200);
            }
            animate();
        }
    });
}

async function processImage(img) {

    setInterval(() => {
        displayFinishedAnimations();
    }, 3000);
    
    processedImages = {};
    animationStatus = {};

    const defaultImageCount = parseInt(imageCountInput.value);
    displayEffectButtons();

    const existingGeneratedImages = generatedImages ? [...generatedImages] : [];

    if (!existingGeneratedImages.length) {
        generatedImages = [];
    }
  
    for (const effect of effects.filter(effect => document.getElementById(`${effect}Checkbox`).checked)) {
        processedImages[effect] = [];
        animationStatus[effect] = false; // Mark as not finished initially

        if (existingGeneratedImages && existingGeneratedImages.length > 0) {
            // // console.log(`Processing ${existingGeneratedImages.length} generated images`);
            
            // Process each generated image
            for (let i = 0; i < existingGeneratedImages.length; i++) {
                try {
                    let processedImage;
                    const generatedImg = existingGeneratedImages[i];
                    // // console.log(selectedRegions);
                    // Convert the generated image to HTMLImageElement
                    if (generatedImg instanceof HTMLImageElement) {
                        processedImage = generatedImg;
                        
                    } else if (typeof generatedImg === 'string' && 
                             (generatedImg.startsWith('data:image') || generatedImg.startsWith('http'))) {
                        
                                // // console.log(selectedRegions);
                                        processedImage = await new Promise((resolve, reject) => {
                            const tempImg = new Image();
                            tempImg.onload = () => resolve(tempImg);
                            tempImg.onerror = reject;
                            tempImg.src = generatedImg;
                        });
                    } else if (generatedImg && generatedImg.imageUrl) {
                        // // console.log(selectedRegions);
                        processedImage = await new Promise((resolve, reject) => {
                            const tempImg = new Image();
                            tempImg.onload = () => resolve(tempImg);
                            tempImg.onerror = reject;
                            tempImg.src = generatedImg.imageUrl;
                        });
                    }

                    if (processedImage) {
                        // Create new canvas and context for this specific generated image
                        const canvas = document.createElement('canvas');
                        canvas.width = processedImage.width;
                        canvas.height = processedImage.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(processedImage, 0, 0);
                        // // console.log(selectedRegions);
                        // Get unique imageData for this generated image
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        // // console.log(selectedRegions)

                        // // console.log(`Processing generated image ${i + 1} with unique imageData`);
                        const value = getEffectValue(effect, i, existingGeneratedImages.length);

                        const processedImageData = await applyEffect(effect, imageData, value, selectedRegions);
                        
                        // Create new canvas for the processed result
                        const resultCanvas = document.createElement('canvas');
                        resultCanvas.width = processedImage.width;
                        resultCanvas.height = processedImage.height;
                        const resultCtx = resultCanvas.getContext('2d');
                        resultCtx.putImageData(processedImageData, 0, 0);
                        // // console.log(selectedRegions);
                        const processedResult = {
                            value: value,
                            dataUrl: resultCanvas.toDataURL(),
                            sourceType: 'generated',
                            sourceIndex: i
                        };
                        animationStatus[effect] = true;
                        console.log(`Finished processing: ${effect}`);
            
                        processedImages[effect].push(processedResult);
                        // // console.log(selectedRegions);
                        sourceImages.push({
                            index: value,
                            type: `${effect} leg`,
                            image: resultCanvas, // Use the processed canvas
                            imageUrl: resultCanvas.toDataURL(),
                            imageData: processedImageData.data,
                            width: processedImageData.width,
                            height: processedImageData.height,
                            sourceType: 'generated',
                            sourceIndex: i,
                            value: value
                        });
                        // // console.log(selectedRegions);
                        updateEffectDisplay(effect);
                        // // console.log(selectedRegions);
                        // if (Date.now() - processStartTime >= 3000) {
                        //     displayFinishedAnimations();
                        // }
                    }

                    
                } catch (error) {
                    console.error(`Error processing generated image ${i + 1}:`, error);
                }
            }
        } 
        // If no generated images, process original image with variations
        else if (img instanceof HTMLImageElement) {
         
            for (let i = 0; i < defaultImageCount; i++) {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    let value = getEffectValue(effect, i, defaultImageCount);
           
                    const processedImageData = await applyEffect(effect, imageData, value, selectedRegions);
                    
                    const resultCanvas = document.createElement('canvas');
                    resultCanvas.width = img.width;
                    resultCanvas.height = img.height;
                    const resultCtx = resultCanvas.getContext('2d');
                    // console.log(processedImageData);
                    resultCtx.putImageData(processedImageData, 0, 0);
                    // // console.log(selectedRegions);
                    const processedResult = {
                        value: value,
                        dataUrl: resultCanvas.toDataURL(),
                        sourceType: 'original',
                        sourceIndex: 0
                    };
                    // // console.log(selectedRegions);
                    animationStatus[effect] = true;
                    console.log(`Finished processing: ${effect}`);
        
                    processedImages[effect].push(processedResult);
                    
                    // Add to generated images for future processing
                    generatedImages.push({
                        index: value,
                        type: `${effect} leg`,
                        image: resultCanvas,
                        imageUrl: resultCanvas.toDataURL(),
                        imageData: processedImageData.data,
                        width: processedImageData.width,
                        height: processedImageData.height,
                        sourceType: 'original',
                        sourceIndex: 0,
                        value: value
                    });
                    // animationStatus[effect] = true;
                    // console.log(`Finished processing: ${effect}`);
        
                    // // console.log(selectedRegions);
                    sourceImages.push({
                        index: value,
                        type: `${effect} leg`,
                        image: resultCanvas,
                        imageUrl: resultCanvas.toDataURL(),
                        imageData: processedImageData.data,
                        width: processedImageData.width,
                        height: processedImageData.height,
                        sourceType: 'original',
                        sourceIndex: 0,
                        value: value
                    });
                    // // console.log(selectedRegions);
                    updateEffectDisplay(effect);

                    // if (Date.now() - processStartTime >= 3000) {
                    //     displayFinishedAnimations();
                    // }
                    
                } catch (error) {
                    console.error(`Error processing original image variation ${i + 1}:`, error);
                }
            }
        }
    }
    
    displayProcessedImages();
}

function displayProcessedImages() {
    // resultsContainer.innerHTML = '';
}

function filterEffects(event) {
    const searchTerm = event.target.value.toLowerCase();
    const effectControls = document.getElementById('effectControls');
    
    effects.forEach(effect => {
        const effectDiv = document.querySelector(`.effect-control:has(#${effect}Checkbox)`);
        const effectButton = document.querySelector(`button[data-effect="${effect}"]`);
        
        if (!effectDiv) return;
        
        if (searchTerm === '') {
            // Show all effects when search is empty
            effectDiv.style.display = '';
            if (effectButton) effectButton.style.display = '';
        } else {
            // Show/hide based on search match
            const matches = effect.toLowerCase().includes(searchTerm);
            effectDiv.style.display = matches ? '' : 'none';
            if (effectButton) effectButton.style.display = matches ? '' : 'none';
        }
    });
}


function convertImageRepresentation(imageRepresentation) {
    return new Promise((resolve, reject) => {
        if (imageRepresentation instanceof HTMLImageElement) {
            resolve(imageRepresentation);
        } else if (typeof imageRepresentation === 'string' && (imageRepresentation.startsWith('data:image') || imageRepresentation.startsWith('http'))) {
            const tempImg = new Image();
            tempImg.onload = () => resolve(tempImg);
            tempImg.onerror = reject;
            tempImg.src = imageRepresentation;
        } else if (imageRepresentation && imageRepresentation.imageUrl) {
            const tempImg = new Image();
            tempImg.onload = () => resolve(tempImg);
            tempImg.onerror = reject;
            tempImg.src = imageRepresentation.imageUrl;
        } else {
            reject(new Error('Invalid image representation'));
        }
    });
}

function stopAnimation(effectId) {
    if (activeAnimations.has(effectId)) {
        clearTimeout(activeAnimations.get(effectId));
        activeAnimations.delete(effectId);
    }
}

function startAnimation(img, images, effectId) {
    let currentFrame = 0;
    
    function animate() {
        if (!document.getElementById(`${effectId}-image`)) {
            stopAnimation(effectId);
            return;
        }
        
        img.src = images[currentFrame].dataUrl;
        currentFrame = (currentFrame + 1) % images.length;
        
        const timeoutId = setTimeout(animate, 200);
        activeAnimations.set(effectId, timeoutId);
    }
    
    animate();
}

function processImageWithMethod(processingMethod) {

    if (!useCredits(1)) {
        return; // Stop if not enough credits
    }
    
    const file = imageUpload.files[0];
    if (file) {
        const objectUrl = URL.createObjectURL(file);
        const img = new Image();
        img.onload = function() {
            URL.revokeObjectURL(objectUrl);
            processingMethod(img);
        }
        img.onerror = function() {
            console.error('Failed to load image');
            alert('Failed to load the selected image.');
        }
        img.src = objectUrl;
    } else if (generatedImages && generatedImages.length > 0) {
        // If no uploaded image but generated images exist
        processingMethod(generatedImages[0]);
    } else {
        alert('Please select an image first.');
    }
}

function toggleEffect(button) {
    button.dataset.active = button.dataset.active === 'true' ? 'false' : 'true';
    button.classList.toggle('inactive');
}

function displayEffectImages(effect) {
    resetHoverTimeout(); // Reset the timeout on hover

    resultsContainer.innerHTML = '';
    
    if (document.getElementById(`${effect}Checkbox`).checked) {
        const images = processedImages[effect];
        
        if (images && images.length > 0) {
            const container = document.createElement('div');
            container.className = 'effect-container';
            
            const wrapper = document.createElement('div');
            wrapper.className = 'canvas-wrapper';
            
            // Updated download icon with white fill
            const downloadIcon = document.createElement('div');
            downloadIcon.className = 'download-icon';
            downloadIcon.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-download">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7 10 12 15 17 10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
            `;
            

            const shareIcon = document.createElement('div');
            shareIcon.className = 'share-icon';
            shareIcon.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-share-2">
                    <circle cx="18" cy="5" r="3"/>
                    <circle cx="6" cy="12" r="3"/>
                    <circle cx="18" cy="19" r="3"/>
                    <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
                    <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
                </svg>
            `;

            wrapper.appendChild(shareIcon); // Add share icon to the wrapper

            const img = new Image();
            img.id = `${effect}-image`;
            img.className = 'processed-image';
            
            wrapper.appendChild(img);
            wrapper.appendChild(downloadIcon);
            
            downloadIcon.addEventListener('click', async () => {
                // Updated loading spinner with white fill
                const originalContent = downloadIcon.innerHTML;
                downloadIcon.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-loader-2 animate-spin">
                        <path d="M21 12a9 9 0 1 1-6.219-8.56"/>
                    </svg>
                `;
            
                try {
                    const logo = await new Promise((resolve, reject) => {
                        const logoImg = new Image();
                        logoImg.crossOrigin = "anonymous";
                        logoImg.onload = () => resolve(logoImg);
                        logoImg.onerror = reject;
                        logoImg.src = 'logo1.jpg';
                    });
            
                    const gif = new GIF({
                        workers: 2,
                        quality: 10,
                        width: img.naturalWidth || 400,
                        height: img.naturalHeight || 300,
                        background: '#FFFFFF'  // Set white background
                    });
            
                    const loadedImages = await Promise.all(images.map(imageData => {
                        return new Promise((resolve) => {
                            const tempImg = new Image();
                            tempImg.onload = () => resolve(tempImg);
                            tempImg.src = imageData.dataUrl;
                        });
                    }));
            
                    loadedImages.forEach(loadedImg => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
            
                        canvas.width = loadedImg.width;
                        canvas.height = loadedImg.height;
                        
                        // Fill canvas with white background first
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
            
                        // Draw original image
                        ctx.drawImage(loadedImg, 0, 0);
            
                        const logoSize = {
                            width: loadedImg.width * 0.1,
                            height: loadedImg.height * 0.05
                        };
            
                        const logoPosition = {
                            x: canvas.width - logoSize.width - 10,
                            y: canvas.height - logoSize.height - 10
                        };
            
                        ctx.drawImage(
                            logo,
                            logoPosition.x,
                            logoPosition.y,
                            logoSize.width,
                            logoSize.height
                        );
            
                        gif.addFrame(canvas, { delay: 200 });
                    });
            
                    gif.on('finished', (blob) => {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${effect}-animation.gif`;
                        document.body.appendChild(a);
                        a.click();
            
                        setTimeout(() => {
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        }, 100);
            
                        downloadIcon.innerHTML = originalContent;
                    });
            
                    gif.render();
            
                } catch (error) {
                    console.error('Error creating GIF:', error);
                    // Updated error icon with white fill
                    downloadIcon.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-alert-circle">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="12" y1="8" x2="12" y2="12"/>
                            <line x1="12" y1="16" x2="12.01" y2="16"/>
                        </svg>
                    `;
                    setTimeout(() => {
                        downloadIcon.innerHTML = originalContent;
                    }, 2000);
                }
            });

            imageCanvas.addEventListener('mousemove', (event) => {
                const rect = imageCanvas.getBoundingClientRect();
                crosshairX = event.clientX - rect.left;
                crosshairY = event.clientY - rect.top;
                redrawCanvas();
            });


            let isGenerating = false;

shareIcon.addEventListener('click', async (event) => {
  // Prevent multiple clicks while generating
  if (isGenerating) return;
  
  try {
    isGenerating = true;
    // Show loading state
    shareIcon.disabled = true;
    shareIcon.textContent = 'Generating...'; // or update your UI accordingly

    const logo = await loadWatermarkLogo('logo1.jpg');
    
    const gif = new GIF({
      workers: 2,
      quality: 10,
      width: img.naturalWidth || 400,
      height: img.naturalHeight || 300,
      background: '#FFFFFF'
    });

    const loadedImages = await Promise.all(
      processedImages[effect].map(imageData => loadImage(imageData.dataUrl))
    );

    // Process frames
    loadedImages.forEach(loadedImg => {
      const canvas = createWatermarkedFrame(loadedImg, logo);
      gif.addFrame(canvas, { delay: 200 });
    });

    // Create and share the GIF within the same user gesture context
    const gifPromise = new Promise((resolve, reject) => {
      gif.on('finished', resolve);
      gif.on('error', reject);
    });

    gif.render();

    const blob = await gifPromise;
    const file = new File([blob], `${effect}-animation.gif`, { type: 'image/gif' });

    const shareData = {
      title: 'Check out this animation!',
      text: `Created using Imaginea. Visit ${window.location.href} for more.`,
      files: [file]
    };

    if (navigator.share && navigator.canShare(shareData)) {
      await navigator.share(shareData);
    } else {
      await navigator.clipboard.writeText(window.location.href);
      alert('Link copied to clipboard!');
    }

  } catch (error) {
    console.error('Error sharing GIF:', error);
    if (error.name === 'NotAllowedError') {
      alert('Sharing canceled.');
    } else {
      alert('Error sharing. Please try again.');
    }
  } finally {
    // Reset UI state
    isGenerating = false;
    shareIcon.disabled = false;
    shareIcon.textContent = 'Share'; // or reset to original state
  }
});

function loadWatermarkLogo(logoUrl) {
  return new Promise((resolve, reject) => {
    const logoImg = new Image();
    logoImg.crossOrigin = "anonymous";
    logoImg.onload = () => resolve(logoImg);
    logoImg.onerror = reject;
    logoImg.src = logoUrl;
  });
}

function loadImage(dataUrl) {
  return new Promise((resolve) => {
    const tempImg = new Image();
    tempImg.onload = () => resolve(tempImg);
    tempImg.src = dataUrl;
  });
}

function createWatermarkedFrame(image, logo) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  canvas.width = image.width;
  canvas.height = image.height;
  
  ctx.fillStyle = '#FFFFFF';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(image, 0, 0);
  
  const logoSize = {
    width: image.width * 0.1,
    height: image.height * 0.05
  };
  
  ctx.drawImage(logo, 
    canvas.width - logoSize.width - 10,
    canvas.height - logoSize.height - 10,
    logoSize.width, 
    logoSize.height
  );
  
  return canvas;
}
              
              // Helper Functions
     
              function loadImage(dataUrl) {
                return new Promise((resolve) => {
                  const tempImg = new Image();
                  tempImg.onload = () => resolve(tempImg);
                  tempImg.src = dataUrl;
                });
              }
              
              function createWatermarkedFrame(image, logo) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas dimensions
                canvas.width = image.width;
                canvas.height = image.height;
                
                // Draw white background
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw the main image
                ctx.drawImage(image, 0, 0);
                
                // Calculate logo dimensions and position
                const logoSize = {
                  width: image.width * 0.1,
                  height: image.height * 0.05
                };
                const logoPosition = {
                  x: canvas.width - logoSize.width - 10,
                  y: canvas.height - logoSize.height - 10
                };
                
                // Draw the logo
                ctx.drawImage(logo, logoPosition.x, logoPosition.y, logoSize.width, logoSize.height);
                
                return canvas;
              }
              
              async function createGifFile(blob, effect) {
                return new File([blob], `${effect}-animation.gif`, { type: 'image/gif' });
              }
              
              async function shareGifContent(file) {
                const shareData = {
                  title: 'Check out this animation!',
                  text: `Created using Imaginea. Visit ${window.location.href} for more.`,
                  files: [file]
                };
              
                if (navigator.share && navigator.canShare(shareData)) {
                  await navigator.share(shareData);
                } else {
                  // Fallback to clipboard
                  await navigator.clipboard.writeText(window.location.href);
                  alert('Link copied to clipboard!');
                }
              }
              
              function handleError(error) {
                console.error('Error sharing GIF:', error);
                alert('Sharing failed. Please try again.');
              }

            container.appendChild(wrapper);
            resultsContainer.appendChild(container);
            
            let currentFrame = 0;
            
            function animate() {
                img.src = images[currentFrame].dataUrl;
                currentFrame = (currentFrame + 1) % images.length;
                setTimeout(animate, 200);
            }
            
            animate();
        } else {
            resultsContainer.textContent = 'Processing...';
        }
    } else {
        resultsContainer.textContent = 'Effect not selected';
    }
}




// Updated styles for the download icon
const styles = `
.canvas-wrapper {
    position: relative;
    display: inline-block;
}

.download-icon {
    position: absolute;
    top: 10px;
    right: 10px;
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 50%;
    padding: 8px;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    transition: all 0.2s ease;
    z-index: 10;
}

.download-icon:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.download-icon:active {
    transform: translateY(0);
}

.download-icon svg {
    display: block;
    color: #4CAF50;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.animate-spin {
    animation: spin 1s linear infinite;
}

.effect-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
}
`;

// Add styles to document
if (!document.getElementById('effect-styles')) {
    const styleElement = document.createElement('style');
    styleElement.id = 'effect-styles';
    styleElement.textContent = styles;
    document.head.appendChild(styleElement);
}


let hoverTimeout;

let activeAnimations = new Map(); // Track active animations


function resetHoverTimeout() {
    clearTimeout(hoverTimeout);
    hoverTimeout = setTimeout(displayAllAnimations, 3000); // 3 seconds
}

function displayAllAnimations() {
    resultsContainer.innerHTML = '';
    
    effects.forEach(effect => {
        if (document.getElementById(`${effect}Checkbox`).checked) {
            const images = processedImages[effect];
            
            if (images && images.length > 0) {
                const container = document.createElement('div');
                container.className = 'effect-container';
                
                 // Add a label for the effect
                 const label = document.createElement('div');
                 label.className = 'effect-label';
                 label.textContent = effect; // Use the effect name as the label
                 container.appendChild(label);
                 
                const wrapper = document.createElement('div');
                wrapper.className = 'canvas-wrapper';
                
                const img = new Image();
                img.id = `${effect}-image`;
                img.className = 'processed-image';
                
                wrapper.appendChild(img);
                container.appendChild(wrapper);
                resultsContainer.appendChild(container);
                
                let currentFrame = 0;
                
                function animate() {
                    img.src = images[currentFrame].dataUrl;
                    currentFrame = (currentFrame + 1) % images.length;
                    setTimeout(animate, 200);
                }
                
                animate();
            }
        }
    });
}


function getEffectValue(effect, index, count) {
    const t = index / (count - 1);
    switch(effect) {
        case 'brightness': return Math.floor(t * 510) - 255;
        case 'hue': return Math.floor(t * 360);
        case 'saturation': return t * 2;
        case 'vintage': case 'ink': case 'vibrance': case 'denoise': case 'hexagonalPixelate': case 'invert':
        case 'perspectiveTilt': case 'perspectiveSqueeze': case 'perspectiveCurve': case 'perspectiveFisheye':
        case 'perspectiveRotate': case 'perspectiveSkew': case 'perspectiveWarp': case 'perspectiveZoom':
        case 'perspectiveTunnel': case 'perspectiveSphere': case 'perspectiveCylinder': case 'perspectiveRipple':
        case 'perspectiveVortex': case 'perspectiveFold': case 'perspectivePixelate': case 'perspectiveEmboss':
        case 'perspectiveMosaic': case 'perspectiveOilPainting': case 'perspectivePosterize':
            return t;
        case 'bulgePinch': return [t, t * 2 - 1];
        case 'swirl': return (t - 0.5) * 10;
        case 'lensBlur': case 'triangularBlur': return t * 50;
        case 'tiltShiftBlur': case 'zoomBlur': return [t, 1-t];
        case 'edgeWork': return t * 10 + 1;
        case 'dotScreen': case 'colorHalftone': return t * 10;
        case 'perspectiveTwist': return t * Math.PI * 2;
        case 'perspective': return [t, 1-t, t, 1-t];
        case 'kaleidoscope': return Math.floor(t * 16) + 2;
        case 'wavyDistortion': return [t * 50, (1-t) * 50, t * Math.PI * 2];
        case 'blockDissolve': return Math.floor(t * 20) + 1;
        case 'rgbShift': return [t * 10, (1-t) * 10, t * 10];
        case 'chromaticAberration': return t * 20;
        case 'droste': return [t * 5, (1-t) * 5, t * Math.PI * 2];
        case 'running1': return [
                t * 10,           
                (1-t) * 1,        
                t * Math.PI * 2,  // Leg swing
                (1-t) * Math.PI   // Arm swing
            ];
        case 'running2': return [
            t, // time
            0.5 + t * 1.5, // speed
            0.2 + t * 0.8 // intensity
        ];
        case 'running3': return t;
        case 'running4': return t;
        case 'running5': return t; 
        case 'running6': return t;
        case 'running7': return t;
        case 'running8': return t;
        case 'running9': return t; 
        case 'running10': return t;
        case 'running11': return t;
        case 'running12': return t; 
        case 'running13': return t; 
        default: return t;
    }
}


        function generateBrightnessVariations() {
            const imageCount = parseInt(document.getElementById('imageCount').value);
            const maxBrightness = parseInt(document.getElementById('brightness').value);
            
            const value1 = parseInt(document.getElementById('value1').value);
            const value2 = parseInt(document.getElementById('value2').value);
            const value3 = parseInt(document.getElementById('value3').value);
            const value4 = parseInt(document.getElementById('value4').value);
            const value5 = parseInt(document.getElementById('value5').value);

            const worker = new Worker('js/brightnessWorker.js');
            worker.postMessage({
                imageData: originalImageData,  // Use originalImageData instead of canvas data
                selectedRegions: selectedRegions,
                imageCount: imageCount,
                maxBrightness: maxBrightness,
                value1: value1,
                value2: value2,
                value3: value3,
                value4: value4,

                value5: value5,
                clickedPoints: clickedPoints,
                lines: lines // Add lines array
            });

            worker.onmessage = function(e) {
                // displaySegmentedImages(e.data.segmentedImages);
                if (e.data.error) {
                    reject(new Error(`Error in ${effect} worker: ${e.data.error}`));
                } else {
                    // console.log('e.data.segmentedImages :>> ', e.data.segmentedImages);
                    resolve(e.data.segmentedImages[0]); // Updated to match worker response format
                }
            };
        }

        function displaySegmentedImages(segmentedImages) {
            const container = document.getElementById('generatedImages');
            if (container) {
                container.innerHTML = '';

                const canvas = document.createElement('canvas');
                canvas.width = segmentedImages[0].width;
                canvas.height = segmentedImages[0].height;
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                let currentFrame = 0;

                function animate() {
                    ctx.putImageData(segmentedImages[currentFrame], 0, 0);
                    currentFrame = (currentFrame + 1) % segmentedImages.length;
                    setTimeout(animate, 200); 
                }

                animate();
            } else {
                console.error("Element with ID 'generatedImages' not found.");
            }
        }

    


        
const BODY_PARTS = {
    'left_face': { name: 'Left Face', description: 'Left side of the face' },
    'right_face': { name: 'Right Face', description: 'Right side of the face' },
    'left_upper_arm_front': { name: 'Left Upper Arm (Front)', description: 'Front of left upper arm' },
    'left_upper_arm_back': { name: 'Left Upper Arm (Back)', description: 'Back of left upper arm' },
    'right_upper_arm_front': { name: 'Right Upper Arm (Front)', description: 'Front of right upper arm' },
    'right_upper_arm_back': { name: 'Right Upper Arm (Back)', description: 'Back of right upper arm' },
    'left_lower_arm_front': { name: 'Left Lower Arm (Front)', description: 'Front of left forearm' },
    'left_lower_arm_back': { name: 'Left Lower Arm (Back)', description: 'Back of left forearm' },
    'right_lower_arm_front': { name: 'Right Lower Arm (Front)', description: 'Front of right forearm' },
    'right_lower_arm_back': { name: 'Right Lower Arm (Back)', description: 'Back of right forearm' },
    'left_hand': { name: 'Left Hand', description: 'Left hand' },
    'right_hand': { name: 'Right Hand', description: 'Right hand' },
    'torso_front': { name: 'Torso Front', description: 'Front of the torso' },
    'torso_back': { name: 'Torso Back', description: 'Back of the torso' },
    'left_upper_leg_front': { name: 'Left Upper Leg (Front)', description: 'Front of left thigh' },
    'left_upper_leg_back': { name: 'Left Upper Leg (Back)', description: 'Back of left thigh' },
    'right_upper_leg_front': { name: 'Right Upper Leg (Front)', description: 'Front of right thigh' },
    'right_upper_leg_back': { name: 'Right Upper Leg (Back)', description: 'Back of right thigh' },
    'left_lower_leg_front': { name: 'Left Lower Leg (Front)', description: 'Front of left calf' },
    'left_lower_leg_back': { name: 'Left Lower Leg (Back)', description: 'Back of left calf' },
    'right_lower_leg_front': { name: 'Right Lower Leg (Front)', description: 'Front of right calf' },
    'right_lower_leg_back': { name: 'Right Lower Leg (Back)', description: 'Back of right calf' },
    'left_foot': { name: 'Left Foot', description: 'Left foot' },
    'right_foot': { name: 'Right Foot', description: 'Right foot' },
    'left_upper_foot': { name: 'Left Upper Foot', description: 'Upper part of left foot' },
    'left_lower_foot': { name: 'Left Lower Foot', description: 'Lower part of left foot' },
    'right_upper_foot': { name: 'Right Upper Foot', description: 'Upper part of right foot' },
    'right_lower_foot': { name: 'Right Lower Foot', description: 'Lower part of right foot' }
};
