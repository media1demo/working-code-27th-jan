<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-87LBKLRFYV"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-87LBKLRFYV');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video generator</title>
    <link rel="stylesheet" href="styles2.css">
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.4/dist/tesseract.min.js"></script>
    <script src = "effects.js"></script>
    <script src = "removewatermark.js"></script>
    <script src = "objremovelipsync.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix"></script>
</head>
<h1 style="display: none;">Image to Animation without GPU</h1>

<body>
    <div class="hamburger-menu">
        <button class="hamburger-button">â˜°</button>
        <div class="dropdown-content">
            <button id="refundBtn">Refund Policy</button>
            <button id="policyBtn">Privacy Policy</button>
            <button id="tncBtn">Terms & Conditions</button>
        </div>
    </div>


    <div id="contactBar" style="
        background: #1a1a2e;
        color: white;
        padding: 2px;
        text-align: center;
        width: 100%;
        position: fixed;
        bottom: 0;
        left: 0;
    ">
    Contact us: <a href="mailto:stejas809@gmail.com" style="color: white; text-decoration: none;">stejas809@gmail.com</a> | 
    Phone: <a href="tel:+918850362898" style="color: white; text-decoration: none;">+91-8850362898</a>
</div>
    <div id="videoModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 1200; justify-content: center; align-items: center;">
        <div id="videoModalContent" style="background: #2a2a4f; padding: 20px; border-radius: 15px; 
        min-width: 85%; min-height: 80%; max-width: 95%; max-height: 90%; /* increased size */
        display: flex; flex-direction: column; gap: 15px;">
       <iframe id="youtubeVideo" width="720" height="405"  <!-- Larger iframe -->
               src="" frameborder="0" allowfullscreen></iframe>
       <div style="color: white; text-align: center;">
           <h3>Need Help?</h3>
           <p>Contact our support team:<br>
           Email: stejas809@gmail.com<br>
           Phone: +91-8850362898</p>
       </div>
   </div>
        <button id="closeVideoModal" style="position: absolute; top: 20px; right: 20px; background: #ff4757; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer;">Close</button>
    </div>
    <div id="pricingModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 1100; justify-content: center; align-items: center;">
        <div id="modalContent" style="background: #000000; padding: 20px; border-radius: 15px; max-width: 90%; max-height: 90%; overflow-y: auto; display: flex; gap: 20px; flex-wrap: nowrap; min-width: 80%;">
            <!-- Content from pricing.html will be inserted here -->
        </div>
        <button id="closeModal" style="position: absolute; top: 20px; right: 20px; background: #ff4757; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer;">Close</button>
    </div>
    <div class="top-nav">
        <div id="creditSystem">
            <div id="creditBalance">Credits: 0</div>
            <button id="buyCredits">Buy Credits</button>
            <button id="startFreeTrial">Start Free Trial</button>
        </div>
    </div>
    <div class="top-centered-container">
        <button id="investorRelations" class="centered-button">
            Investor Relations
        </button>
    </div>
    <img id="sourceImage" crossorigin="anonymous" style="display: none;">
    <div id="mainContainer" style="display: none;">
    </div>
    <canvas id="visualizationCanvas" style="display: none;"></canvas>
    <div id="imageDisplay" class="image-container"></div>
    <div id="searchBarContainer">
        <input type="text" id="effectSearchBar" placeholder="Search for effects...">
    </div>
    <div id="sidebar">
        <button id = "magicWandTool" style="display: none;">.</button>
     <button id="lassoTool">Lasso Tool</button>
         <button id="polygonLassoTool">Polygon Lasso Tool</button> <!-- New button -->
         <button id="circleMagicWandTool">Circle Magic Wand</button>
        <div class="timer-wrapper">
            <div class="timer-container">
                    <div class="digital-timer" id="timer">00:000</div>
                    <div class="timer-label"></div>
            </div>
        </div>
        
        <div class="controls" id = "side1barcontrols">
            <input type="file" id="imageUpload" accept="image/*">
            <label for="imageCount">Number of images per effect:</label>
            <input type="number" id="imageCount" min="1" max="100" value="3">
            <button id="processButton">Process Image</button>
            <select id="actionSelect" class="action-dropdown">   
                <option value="">Select Action</option>
                <option value="visualizeBtn" id="visualizeBtn">Visualize</option>
                <option value="visualizeBtn1" id="visualizeBtn1">Visualizesmall</option>
                <option value="keypointsButton" id="keypointsButton">Hand</option>
                <option value="legButton" id="legButton">Leg</option>
                <option value="legButton1" id="legButton1">Left Foot</option>
                <option value="legButton2" id="legButton2">Right Foot</option>
                <option value="leftlegonlyid" id="leftlegonlyid">Left Leg Only</option>
                <option value="rightlegonlyid" id="rightlegonlyid">Right Leg Only</option>
                <option value="rightarmonlyid" id="rightarmonlyid">Right Arm Only</option>
                <option value="leftarmonlyid" id="leftarmonlyid">Left Arm Only</option>
            </select>
            <div>
                <label for="widthInput">Target Width:</label>
                <input type="number" id="widthInput" min="1" step="1">
            </div>
            <div>
                <label for="heightInput">Target Height:</label>
                <input type="number" id="heightInput" min="1" step="1">
            </div>
            <button id="resizeButton">Resize Image</button>
            <button id="toggleDraw">Toggle Draw Mode</button>
            <button id="removeObject">Remove Object</button>
            <button id="lipSyncButton">Lip Sync Animation</button> <!-- New button -->
            <button id="generateImages">Generate Images</button> <!-- Brightness button -->
            <button id="removeWatermarkButton">Remove Watermark</button>
            <label for="brightness">Max Brightness Change:</label>
            <button id="addMagicWand">Addmagicwand</button>
            <button id="subtractMagicWand">Subtractmagicwand</button>
            <button id="invertMagicWand">Invertmagicwand</button>
            <input type="range" id="brightness" min="0" max="255" value="100">
            <input type="number" id="value1" value="0">
            <input type="number" id="value2" value="0">
            <input type="number" id="value3" value="0">
            <input type="number" id="value4" value="0">
            <input type="number" id="value5" value="0">
            <button id="fastProcessButton">Fast Process</button>
        </div>
        
        <div id="selectAllCheckboxControl">
            <input type="checkbox" id="selectAllCheckbox">
            <label for="selectAllCheckbox">Select All Effects</label>
        </div>
    </div>
    <div id="masterCheckboxControl">
        <input type="checkbox" id="masterCheckbox" checked>
        <label for="masterCheckbox">Select/Unselect All</label>
    </div>

    <div id="mainContent">
        <div id="imageContainer">
            <div class="image-wrapper" >
                <img id="originalImage" alt="Original Image" style ="display: none;">
            </div>
            <div class="image-wrapper">
                <img id="segmentedImage" alt="Segmented Image" style ="display: none;">
            </div>
        </div>    
        <div id="resultsContainer">
         
        </div>
        <canvas id="imageCanvas"></canvas>
        <div id="generatedImages"></div>
        <div id="segmentsContainer"></div>
        <div id="progress"></div> <!-- Added progress div -->
        <div id = "canvasContainer"></div>
        <!-- <div id="imageContainer">
            <div class="image-wrapper" >
           
                
                <img id="originalImage" alt="Original Image" style ="display: none;">
            </div>
            <div class="image-wrapper">
           
                
                <img id="segmentedImage" alt="Segmented Image" style ="display: none;">
            </div>
        </div> -->
    
    </div>

    <div id="effectControls"></div>
    <script src= "main.js"></script>

<script>


window.onload = () => {
    if (freeTrialInterval === null) {
        freeTrialInterval = setInterval(() => {
            credits += 2; // 2 credits every minute
            updateCreditBalance();
        }, 60000);
    }
};

let credits = 10000;
let freeTrialInterval = null;


function updateCreditBalance() {
    document.getElementById('creditBalance').textContent = `Credits: ${credits}`;
    localStorage.setItem('credits', credits);
}


function useCredits() {

    const selectedEffects = effects.filter(effect => 
        document.getElementById(`${effect}Checkbox`).checked
    ).length;

    const imageCount = parseInt(document.getElementById('imageCount').value) || 3;

    const totalCreditsRequired = selectedEffects * imageCount;

    if (credits >= totalCreditsRequired) {
      
        
        credits -= totalCreditsRequired; // Deduct the total credits
        console.log('credits :>> ', credits);
        updateCreditBalance();
        return true; // Credits were successfully deducted
    } else {
        alert(`Not enough credits! You need ${totalCreditsRequired} credits but only have ${credits}.`);
        return false; // Not enough credits
    }
}

        document.addEventListener('DOMContentLoaded', function() {


            resetHoverTimeout();
    

            document.querySelectorAll('.effect-button').forEach(button => {
    button.addEventListener('mouseenter', () => {
        resetHoverTimeout();
        displayEffectImages(button.dataset.effect);
    });
});

            const FTUE = {
    // Local storage key
    VISIT_COUNT_KEY: 'visitCount',
    TUTORIAL_SEEN_KEY: 'image_processor_tutorial_seen',
    
    // HTML template for the welcome modal
    welcomeModalHTML: `
        <div id="welcomeModal" class="welcome-modal">
            <div class="welcome-content">
                <div class="welcome-header">
                    <div class="welcome-title">
                        <h2>Welcome to Image Processor! ðŸŽ¨</h2>
                        <div class="pulse-dot"></div>
                    </div>
                    <button class="close-welcome">&times;</button>
                </div>
                <div class="welcome-body">
                    <div class="welcome-step active" data-step="1">
                        <div class="step-number">1</div>
                        <div class="step-content">
                            <h3>Let's Get Started!</h3>
                            <p>Would you like a quick tour of the essential features?</p>
                            <div class="welcome-buttons">
                                <button class="start-tutorial">Yes, show me around</button>
                                <button class="skip-tutorial">Maybe later</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="welcome-footer">
                    <label class="dont-show-again">
                        <input type="checkbox" id="dontShowAgain">
                        Don't show this again
                    </label>
                </div>
            </div>
        </div>
    `,

    // CSS styles for the welcome modal
    styles: `
        .welcome-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .welcome-modal.show {
            opacity: 1;
        }

        .welcome-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px;
            opacity: 0;
            transition: all 0.3s ease-in-out;
        }

        .welcome-modal.show .welcome-content {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .welcome-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .welcome-title {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .welcome-title h2 {
            margin: 0;
            color: #2d3748;
            font-size: 24px;
        }

        .pulse-dot {
            width: 10px;
            height: 10px;
            background: #48bb78;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(72, 187, 120, 0.7);
            }
            70% {
                transform: scale(1);
                box-shadow: 0 0 0 10px rgba(72, 187, 120, 0);
            }
            100% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(72, 187, 120, 0);
            }
        }

        .close-welcome {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #a0aec0;
            transition: color 0.2s;
        }

        .close-welcome:hover {
            color: #2d3748;
        }

        .welcome-step {
            display: none;
            opacity: 0; 
            transform: translateY(20px);
            transition: all 0.3s ease-in-out;
        }

        .welcome-step.active {
            display: flex;
            gap: 20px;
            opacity: 1;
            transform: translateY(0);
        }

        .step-number {
            width: 40px;
            height: 40px;
            background: #ebf8ff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #3182ce;
            flex-shrink: 0;
        }

        .step-content {
            flex-grow: 1;
        }

        .step-content h3 {
            margin: 0 0 10px 0;
            color: #2d3748;
        }

        .step-content p {
            margin: 0;
            color: #4a5568;
            line-height: 1.5;
        }

        .welcome-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .start-tutorial, .skip-tutorial {
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

        .start-tutorial {
            background: #4299e1;
            color: white;
            border: none;
        }

        .start-tutorial:hover {
            background: #3182ce;
        }

        .skip-tutorial {
            background: white;
            color: #4a5568;
            border: 1px solid #e2e8f0;
        }

        .skip-tutorial:hover {
            background: #f7fafc;
        }

        .welcome-footer {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e2e8f0;
        }

        .dont-show-again {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #718096;
            cursor: pointer;
        }

        .dont-show-again input {
            margin: 0;
        }
    `,

    initialize() {

        const styleSheet = document.createElement('style');
        styleSheet.textContent = this.styles;
        document.head.appendChild(styleSheet);

        // Add modal to document
        document.body.insertAdjacentHTML('beforeend', this.welcomeModalHTML);

        // Track visits
        const visitCount = trackVisits();

        // Only show tutorial for first and second visits
        if (visitCount <= 2) {
            this.showWelcomeModal();
        }

        // Setup event listeners
        this.setupEventListeners();
    },

    showWelcomeModal() {
        const modal = document.getElementById('welcomeModal');
        modal.style.display = 'block';
        // Trigger reflow
        modal.offsetHeight;
        modal.classList.add('show');
    },

    hideWelcomeModal() {
        const modal = document.getElementById('welcomeModal');
        modal.classList.remove('show');
        setTimeout(() => {
            modal.style.display = 'none';
        }, 300);
    },

    setupEventListeners() {
        // Close button
        document.querySelector('.close-welcome').addEventListener('click', () => {
            this.hideWelcomeModal();
        });

        // Start tutorial button
        document.querySelector('.start-tutorial').addEventListener('click', () => {
            this.hideWelcomeModal();
            this.startTutorial();
        });

        // Skip tutorial button
        document.querySelector('.skip-tutorial').addEventListener('click', () => {
            this.hideWelcomeModal();
        });

        // Don't show again checkbox
        document.querySelector('#dontShowAgain').addEventListener('change', (e) => {
            if (e.target.checked) {
                localStorage.setItem(this.TUTORIAL_SEEN_KEY, 'true');
            } else {
                localStorage.setItem(this.TUTORIAL_SEEN_KEY, 'false');
            }
        });

        // Close modal when clicking outside
        document.getElementById('welcomeModal').addEventListener('click', (e) => {
            if (e.target.id === 'welcomeModal') {
                this.hideWelcomeModal();
            }
        });
    },

    startTutorial() {
        const tutorial = new ImageProcessingTutorial();
        tutorial.start();
    }
};

            
FTUE.initialize();

    
        let modalCount = localStorage.getItem('modalCount') || 0;
            if (modalCount < 2) {
                openVideoModal('https://www.youtube.com/embed/7h8WZqMG6gU?si=E9DIW9PTURuBS2ZJ');
                localStorage.setItem('modalCount', ++modalCount);
            }

            function openVideoModal(videoUrl) {
                const videoModal = document.getElementById('videoModal');
                const youtubeVideo = document.getElementById('youtubeVideo');
                youtubeVideo.src = videoUrl;
                videoModal.style.display = 'flex';
            }

            function closeVideoModal() {
                const videoModal = document.getElementById('videoModal');
                const youtubeVideo = document.getElementById('youtubeVideo');
                youtubeVideo.src = '';
                videoModal.style.display = 'none';
            }

            document.getElementById('closeVideoModal').addEventListener('click', closeVideoModal);

            document.getElementById('videoModal').addEventListener('click', function(event) {
                if (event.target === this) {
                    closeVideoModal();
                }
            });

// Event listener for the close button
document.getElementById('closeVideoModal').addEventListener('click', closeVideoModal);

// Event listener to close the modal when clicking outside of it
document.getElementById('videoModal').addEventListener('click', function(event) {
    if (event.target === this) {
        closeVideoModal();
    }
});

    initializeEffectControls();

const effectSearchBar = document.getElementById('effectSearchBar');
effectSearchBar.addEventListener('input', filterEffects);

// Initialize credits to 10000 if no value is stored in localStorage
credits = parseInt(localStorage.getItem('credits')) || 10000;
updateCreditBalance();

if (freeTrialInterval === null) {
    freeTrialInterval = setInterval(() => {
        credits += 2; // 2 credits every minute
        updateCreditBalance();
    }, 60000); // 60000 milliseconds = 1 minute
}



    document.getElementById('buyCredits').addEventListener('click', () => {
    // Show pricing modal
    document.getElementById('pricingModal').style.display = 'flex';
    


    // Load pricing content dynamically
    fetch('pricing.html')
        .then(response => response.text())
        .then(html => {
            document.getElementById('modalContent').innerHTML = html;
            
            // Add event listeners to pricing buttons
            document.querySelector('.basic button').addEventListener('click', function(e) {
                e.preventDefault();
                credits += 10000;
                updateCreditBalance();
                // window.open(this.getAttribute('href'), '_blank');
                document.getElementById('pricingModal').style.display = 'none';
            });
            
            document.querySelector('.standard button').addEventListener('click', function(e) {
                e.preventDefault();
                credits += 1000000;
                updateCreditBalance();
                // window.open(this.getAttribute('href'), '_blank');
                document.getElementById('pricingModal').style.display = 'none';
            });
        });
    }); 

document.getElementById('investorRelations').addEventListener('click', function() {
    // Find the iframe in your document
    const iframe = document.querySelector('iframe');
    
    if (iframe) {
        // Load the banner.html URL into the existing iframe
        iframe.src = 'https://tejas36026.github.io/working-code-27th-jan/banner.html';
    } else {
        // Fallback if no iframe is found
        console.error('No iframe found in the document');
        window.open('https://tejas36026.github.io/working-code-27th-jan/banner.html', '_blank');
    }
});
    document.getElementById('closeModal').addEventListener('click', function () {
    const pricingModal = document.getElementById('pricingModal');
    pricingModal.style.display = 'none';
});


    document.getElementById('pricingModal').addEventListener('click', function (event) {
    if (event.target === this) {
        this.style.display = 'none';
    }
});

    document.getElementById('startFreeTrial').addEventListener('click', () => {
    if (freeTrialInterval === null) {
        freeTrialInterval = setInterval(() => {
            credits += 10; // 10 credits every minute
            updateCreditBalance();
        }, 60000); // 60000 milliseconds = 1 minute
    
    
    }
    credits += 10000;
    updateCreditBalance();
    }   );



    document.getElementById('imageUpload').addEventListener('change', function(event) {
        const file = event.target.files[0];
        const reader = new FileReader();
        
        reader.onload = function(e) {
            const img = document.getElementById('sourceImage');
            img.src = e.target.result;
            img.onload = async () => {
                await loadModels();
                await prepareSegmentation();
            };
        };
        
        reader.readAsDataURL(file);
    });

    const actionSelect = document.getElementById('actionSelect');

    // Add a change event listener to handle all actions
    actionSelect.addEventListener('change', function(e) {
    // Get the selected value
    const selectedAction = e.target.value;

    // Handle each action based on the selected value
    switch(selectedAction) {
        case 'visualizeBtn':
            startProcessing('visualize');
            break;
            case 'visualizeBtn1':
            startProcessing1('visualize');
            break;
        case 'keypointsButton':
            handcode();
            break;
        case 'legButton':
            legcode();
            break;
        case 'legButton1':
            legfootcode();
            break;
        case 'legButton2':
            rightfootcode();
            break;
        case 'leftlegonlyid':
            leftlegonly();
            break;
        case 'rightlegonlyid':
            rightlegonly();
            break;
        case 'rightarmonlyid':
            rightarmonly();
            break;
        case 'leftarmonlyid':
            leftarmonly();
            break;
    }
    });

    });


class ImageProcessingTutorial {
    constructor() {
        this.setupCursor();
        this.setupTooltip();
        this.setupProgressIndicator();
        this.steps = this.defineSteps();
        this.currentStepIndex = 0;
    }

    setupCursor() {
        this.cursor = document.createElement('div');
        this.cursor.style.cssText = `
            position: fixed;
            width: 20px;
            height: 20px;
            background: rgba(255, 0, 0, 0.5);
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            transition: all 0.5s ease;
            box-shadow: 0 0 0 4px rgba(255, 0, 0, 0.2);
        `;
        document.body.appendChild(this.cursor);
    }

    setupTooltip() {
        this.tooltip = document.createElement('div');
        this.tooltip.style.cssText = `
            position: fixed;
            background: #2a2a4f;
            color: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            z-index: 10001;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transition: opacity 0.3s ease;
            font-size: 14px;
        `;
        document.body.appendChild(this.tooltip);
    }

    setupProgressIndicator() {
        this.progressBar = document.createElement('div');
        this.progressBar.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #2a2a4f;
            padding: 10px 20px;
            border-radius: 20px;
            color: white;
            z-index: 10002;
            display: flex;
            gap: 10px;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        `;
        document.body.appendChild(this.progressBar);
    }

    
defineSteps() {
    return [
        {
            element: '#closeVideoModal',
            title: 'Close Video Modal',
            description: 'First, let\'s close the video modal to access the main interface.',
            action: 'click',
            position: 'bottom'
        },
        {
            element: '#imageUpload',
            title: 'Upload Your Image',
            description: 'Click here to choose an image file from your computer. Supported formats: JPEG, PNG, etc.',
            action: 'click',
            position: 'right',
            waitForEvent: 'change'
        },
        {
            element: '#lassoTool',
            title: 'Select Lasso Tool',
            description: 'The Lasso Tool allows you to make precise selections around objects in your image. Click to activate.',
            action: 'click',
            position: 'right'
        },
        {
            element: '#imageCanvas',
            title: 'Make Your Selection',
            description: 'Select the area on the image and then press the process image button.',
            action: 'waitForSelection',
            position: 'center'
        },
        {
            element: '#processButton',
            title: 'Process Selection',
            description: 'Now click the "Process Image" button to process your selection.',
            action: 'waitForProcessClick',
            position: 'left'
        },
        {
            element: '#resultsContainer',
            title: 'Processing Results',
            description: 'Wait while your selection is being processed...',
            action: 'waitForResults',
            position: 'right'
        },
        {
            element: '#effectControls',
            title: 'Effect Controls',
            description: 'Now you can adjust various effects and see the results in real-time.',
            action: 'explainEffects',
            position: 'left'
        }
    ];
}






    updateProgressBar() {
        const total = this.steps.length;
        const current = this.currentStepIndex + 1;
        this.progressBar.innerHTML = `
            <span>Step ${current} of ${total}</span>
            <div style="width: 200px; height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; overflow: hidden;">
                <div style="width: ${(current/total)*100}%; height: 100%; background: white; transition: width 0.3s ease;"></div>
            </div>
        `;
    }


    showTooltip(element, step) {
        const rect = element.getBoundingClientRect();
        const positions = {
            'top': {
                top: rect.top - 10 - this.tooltip.offsetHeight,
                left: rect.left + (rect.width/2) - (this.tooltip.offsetWidth/2)
            },
            'bottom': {
                top: rect.bottom + 10,
                left: rect.left + (rect.width/2) - (this.tooltip.offsetWidth/2)
            },
            'left': {
                top: rect.top + (rect.height/2) - (this.tooltip.offsetHeight/2),
                left: rect.left - 10 - this.tooltip.offsetWidth
            },
            'right': {
                top: rect.top + (rect.height/2) - (this.tooltip.offsetHeight/2),
                left: rect.right + 10
            }
        };

        const pos = positions[step.position] || positions.bottom;
        this.tooltip.style.top = `${pos.top}px`;
        this.tooltip.style.left = `${pos.left}px`;
        this.tooltip.innerHTML = `
            <h3 style="margin: 0 0 8px 0; font-size: 16px;">${step.title}</h3>
            <p style="margin: 0;">${step.description}</p>
        `;
        this.tooltip.style.opacity = '1';
    }


    async waitForSelection() {
    return new Promise((resolve) => {
        const canvas = document.querySelector('#imageCanvas');
        if (!canvas) {
            console.warn('Canvas not found, skipping selection wait');
            resolve();
            return;
        }

        let isSelecting = false; // Track if the user is actively selecting
        let points = []; // Store the points of the selection

        // Listen for mousedown to start the selection
        const onMouseDown = (e) => {
            isSelecting = true;
            points = []; // Reset points
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            points.push({ x, y }); // Add the first point
            this.tooltip.innerHTML = `
                <h3 style="margin: 0 0 8px 0; font-size: 16px;">Making Selection</h3>
                <p style="margin: 0;">Click and drag to draw your selection. Double-click or connect back to the start point to complete.</p>
            `;
        };

        // Listen for mousemove to track the selection
        const onMouseMove = (e) => {
            if (isSelecting) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                points.push({ x, y }); // Add the current point
                this.drawSelectionPreview(canvas, points); // Draw a preview of the selection
            }
        };

        // Listen for mouseup or double-click to end the selection
        const onMouseUp = (e) => {
            if (isSelecting) {
                isSelecting = false;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                points.push({ x, y }); // Add the final point

                // Check if the selection is complete (e.g., closed shape)
                if (this.isSelectionComplete(points)) {
                    this.tooltip.innerHTML = `
                        <h3 style="margin: 0 0 8px 0; font-size: 16px;">Selection Complete</h3>
                        <p style="margin: 0;">Click "Next" to proceed.</p>
                        <button id="nextStep" style="
                            background: #4CAF50;
                            color: white;
                            border: none;
                            padding: 8px 16px;
                            border-radius: 4px;
                            cursor: pointer;
                            margin-top: 10px;
                        ">Next</button>
                    `;

                    // Add a click handler for the "Next" button
                    const nextButton = this.tooltip.querySelector('#nextStep');
                    nextButton.onclick = () => {
                        canvas.removeEventListener('mousedown', onMouseDown);
                        canvas.removeEventListener('mousemove', onMouseMove);
                        canvas.removeEventListener('mouseup', onMouseUp);
                        canvas.removeEventListener('dblclick', onMouseUp);
                        resolve();
                    };
                }
            }
        };

        // Add event listeners
        canvas.addEventListener('mousedown', onMouseDown);
        canvas.addEventListener('mousemove', onMouseMove);
        canvas.addEventListener('mouseup', onMouseUp);
        canvas.addEventListener('dblclick', onMouseUp); // Allow double-click to complete the selection
    });
}

// Helper method to draw a preview of the selection on the canvas
drawSelectionPreview(canvas, points) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear previous drawings
    ctx.beginPath();
    ctx.strokeStyle = '#4CAF50';
    ctx.lineWidth = 2;
    points.forEach((point, index) => {
        if (index === 0) {
            ctx.moveTo(point.x, point.y);
        } else {
            ctx.lineTo(point.x, point.y);
        }
    });
    ctx.closePath();
    ctx.stroke();
}

// Helper method to check if the selection is complete (e.g., closed shape)
isSelectionComplete(points) {
    if (points.length < 3) return false; // Need at least 3 points to form a shape
    const firstPoint = points[0];
    const lastPoint = points[points.length - 1];
    const distance = Math.sqrt(
        Math.pow(lastPoint.x - firstPoint.x, 2) + Math.pow(lastPoint.y - firstPoint.y, 2)
    );
    return distance < 10; // Consider the shape closed if the last point is close to the first
}

    async waitForProcessButtonClick(element) {
    return new Promise((resolve) => {
        const processButton = element;
        
        // Update tooltip to guide user
        this.tooltip.innerHTML = `
            <h3 style="margin: 0 0 8px 0; font-size: 16px;">Click Process Image</h3>
            <p style="margin: 0;">Click the "Process Image" button to continue.</p>
        `;

        // Add highlight effect to process button
        processButton.style.transition = 'all 0.3s ease';
        processButton.style.boxShadow = '0 0 0 2px #4CAF50';
        
        const clickHandler = () => {
            processButton.style.boxShadow = 'none';
            processButton.removeEventListener('click', clickHandler);
            resolve();
        };
        
        processButton.addEventListener('click', clickHandler);
    
    
    });
}


async waitForProcessingResults() {
    return new Promise((resolve) => {
        const resultsContainer = document.querySelector('#resultsContainer');
        
        // Show processing status
        this.tooltip.innerHTML = `
            <h3 style="margin: 0 0 8px 0; font-size: 16px;">Processing...</h3>
            <p style="margin: 0;">Please wait while your selection is being processed.</p>
            <div class="processing-spinner" style="
                width: 30px;
                height: 30px;
                border: 3px solid #f3f3f3;
                border-top: 3px solid #3498db;
                border-radius: 50%;
                animation: spin 1s linear infinite;
                margin: 10px auto;
            "></div>
        `;

        // Watch for changes in results container
        const observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                if (mutation.addedNodes.length > 0) {
                    // Wait a bit to ensure everything is loaded
                    setTimeout(() => {
                        observer.disconnect();
                        this.tooltip.innerHTML = `
                            <h3 style="margin: 0 0 8px 0; font-size: 16px;">Processing Complete</h3>
                            <p style="margin: 0;">Your selection has been processed. Click "Next" to continue.</p>
                            <button id="nextStep" style="
                                background: #4CAF50;
                                color: white;
                                border: none;
                                padding: 8px 16px;
                                border-radius: 4px;
                                cursor: pointer;
                                margin-top: 10px;
                            ">Next</button>
                        `;
                        
                        this.tooltip.querySelector('#nextStep').onclick = () => resolve();
                    }, 1000);
                }
            }
        });

        observer.observe(resultsContainer, {
            childList: true,
            subtree: true
        });

        // Fallback timeout
        setTimeout(() => {
            observer.disconnect();
            resolve();
        }, 15000);
    });
}

async waitForLassoSelection() {
        return new Promise((resolve) => {
            const canvas = document.querySelector('#imageCanvas');
            let isSelectionActive = false;
            
            // Update tooltip with initial instructions
            this.updateTooltipContent({
                title: 'Make Your Selection',
                description: 'Click and drag on the image to draw around the area you want to process.',
                showButton: false
            });

            const handleSelectionStart = () => {
                if (!isSelectionActive) {
                    isSelectionActive = true;
                    this.updateTooltipContent({
                        title: 'Drawing Selection',
                        description: 'Double click to finish',
                        showButton: false
                    });
                }
            };

            const handleSelectionComplete = () => {
                if (isSelectionActive) {
                    this.updateTooltipContent({
                        title: 'Selection Complete!',
                        description: 'Great! You\'ve completed your selection. Click "Continue" to proceed.',
                        showButton: true,
                        buttonText: 'Continue',
                        buttonCallback: () => {
                            cleanup();
                            resolve();
                        }
                    });
                }
            };

            const cleanup = () => {
                canvas.removeEventListener('mousedown', handleSelectionStart);
                canvas.removeEventListener('dblclick', handleSelectionComplete);
                document.removeEventListener('keydown', handleEscape);
            };

            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    cleanup();
                    resolve();
                }
            };

            canvas.addEventListener('mousedown', handleSelectionStart);
            canvas.addEventListener('dblclick', handleSelectionComplete);
            document.addEventListener('keydown', handleEscape);
        });
    }


    updateTooltipContent({ title, description, showButton = false, buttonText = '', buttonCallback = null }) {
        this.tooltip.innerHTML = `
            <h3 style="margin: 0 0 8px 0; font-size: 16px;">${title}</h3>
            <p style="margin: 0;">${description}</p>
            ${showButton ? `
                <button id="tooltipButton" style="
                    background: #4CAF50;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 4px;
                    cursor: pointer;
                    margin-top: 10px;
                ">${buttonText}</button>
            ` : ''}
        `;

        if (showButton && buttonCallback) {
            this.tooltip.querySelector('#tooltipButton').onclick = buttonCallback;
        }
    }


    async demonstrateLassoSelection(element, path) {
        const rect = element.getBoundingClientRect();
        for (let i = 0; i < path.length; i++) {
            const point = path[i];
            const x = rect.left + (rect.width * point.x);
            const y = rect.top + (rect.height * point.y);
            this.cursor.style.left = `${x}px`;
            this.cursor.style.top = `${y}px`;
            await new Promise(resolve => setTimeout(resolve, 500));
        }
    }


    
    async moveTo(element, step) {
        const rect = element.getBoundingClientRect();
        const x = rect.left + rect.width / 2;
        const y = rect.top + rect.height / 2;
        
        this.cursor.style.left = `${x}px`;
        this.cursor.style.top = `${y}px`;
        
        this.showTooltip(element, step);
        
        switch (step.action) {
            case 'click':
                await new Promise(resolve => setTimeout(resolve, 1000));
                this.cursor.style.transform = 'scale(0.8)';
                await new Promise(resolve => setTimeout(resolve, 200));
                this.cursor.style.transform = 'scale(1)';
                element.click();
                
                if (step.waitForEvent) {
                    await new Promise(resolve => {
                        element.addEventListener(step.waitForEvent, resolve, { once: true });
                    });
                }
                break;

            case 'waitForSelection':
                this.cursor.style.opacity = '0';
                await this.waitForLassoSelection();
                this.cursor.style.opacity = '1';
                break;

            case 'waitForProcessClick':
                this.cursor.style.opacity = '0';
                await this.waitForProcessButtonClick(element);
                this.cursor.style.opacity = '1';
                break;

            case 'waitForResults':
                await this.waitForProcessingResults();
                break;
        }
    }

    

    async startTutorial() {
        try {
            for (let i = 0; i < this.steps.length; i++) {
                this.currentStepIndex = i;
                this.updateProgressBar();
                
                const step = this.steps[i];
                const element = document.querySelector(step.element);
                
                if (!element) {
                    console.warn(`Element ${step.element} not found, skipping step`);
                    continue;
                }
                
                await this.moveTo(element, step);
            }

            // Cleanup
            this.cleanup();
            
            // Show completion message
            // alert('Tutorial completed! You can now use these tools to process your images.');

        } catch (error) {
            console.error('Tutorial error:', error);
            this.cleanup();
        }
    }

    cleanup() {
        [this.cursor, this.tooltip, this.progressBar].forEach(element => {
            if (element && element.parentNode) {
                element.parentNode.removeChild(element);
            }
        });
    }
}


function trackVisits() {
    let visitCount = localStorage.getItem('visitCount');
    if (visitCount === null) {
        visitCount = 0;
    } else {
        visitCount = parseInt(visitCount);
    }
    visitCount++;
    localStorage.setItem('visitCount', visitCount);
    return visitCount;
}

// Initialize and start the tutorial
document.addEventListener('DOMContentLoaded', () => {

    const hamburgerBtn = document.querySelector('.hamburger-button');
            const dropdownContent = document.querySelector('.dropdown-content');

            // Routes for the pages
            const routes = {
                refund: 'https://tejas36026.github.io/working-code-27th-jan/refund.html',
                policy: 'https://tejas36026.github.io/working-code-27th-jan/policy.html',
                tnc: 'https://tejas36026.github.io/working-code-27th-jan/TnC.html'
            };

            // Toggle hamburger menu
            hamburgerBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                dropdownContent.classList.toggle('show');
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!dropdownContent.contains(e.target) && !hamburgerBtn.contains(e.target)) {
                    dropdownContent.classList.remove('show');
                }
            });

            // Setup route buttons
            document.getElementById('refundBtn').addEventListener('click', () => {
                window.location.href = routes.refund;
                dropdownContent.classList.remove('show');
            });

            document.getElementById('policyBtn').addEventListener('click', () => {
                window.location.href = routes.policy;
                dropdownContent.classList.remove('show');
            });

            document.getElementById('tncBtn').addEventListener('click', () => {
                window.location.href = routes.tnc;
                dropdownContent.classList.remove('show');
            });


    const tutorialButton = document.createElement('button');
    tutorialButton.style.display = "none";
    tutorialButton.textContent = 'Start Interactive Tutorial';
    tutorialButton.style.display = "none";

    tutorialButton.style.cssText = `
    
        position: fixed;
        top: 20px;
        right: 100px;
        padding: 10px 20px;
        background: #2a2a4f;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        z-index: 1000;
        font-weight: bold;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    `;
    
    tutorialButton.addEventListener('mouseenter', () => {
        tutorialButton.style.background = '#3a3a6f';
    });
    
    tutorialButton.addEventListener('mouseleave', () => {
        tutorialButton.style.background = '#2a2a4f';
    });
    
    document.body.appendChild(tutorialButton);
    tutorialButton.style.display = "none";

    //     const tutorial = new ImageProcessingTutorial();
    //    tutorial.startTutorial();



    class TutorialManager {
    constructor() {
        this.TUTORIAL_KEY = 'tutorial_shown_count';
    }

    // Get the number of times tutorial has been shown
    getTutorialCount() {
        const count = localStorage.getItem(this.TUTORIAL_KEY);
        return count ? parseInt(count) : 0;
    }

    // Increment the tutorial count
    incrementTutorialCount() {
        const currentCount = this.getTutorialCount();
        localStorage.setItem(this.TUTORIAL_KEY, currentCount + 1);
    }

    // Check if tutorial should be shown
    shouldShowTutorial() {
        const count = this.getTutorialCount();
        return count < 2; // Only show for first two visits
    }

    // Handle tutorial execution
    executeTutorial() {
        if (this.shouldShowTutorial()) {
            const tutorial = new ImageProcessingTutorial();
            tutorial.startTutorial();
            this.incrementTutorialCount();
            return true;
        }
        return false;
    }
}

// Usage example
const tutorialManager = new TutorialManager();
tutorialManager.executeTutorial();
});




let segmentationResult;
let processedData = null; 
let net;
let imageArray = []; 
const viewedImages = []; // Array to store images for further processing
let generatedImages = [];

function processSegmentVariations(imageData, partName) {
    return new Promise((resolve) => {

        segmentationWorker.postMessage({
            imageData: imageData.data,
            partName: partName,
            width: imageData.width,
            height: imageData.height
        });

        segmentationWorker.onmessage = function(e) {
            const { type, extremePoints, averages, partName } = e.data;

            const variations = [{
                data: new Uint8ClampedArray(imageData.data),
                extremePoints: extremePoints,
                points: {}
            }];
            
            if (!collectedPoints.has(partName)) {
                collectedPoints.set(partName, []);
            }

            if (extremePoints && extremePoints.top) collectedPoints.get(partName).push(extremePoints.top);
            if (extremePoints && extremePoints.bottom) collectedPoints.get(partName).push(extremePoints.bottom);

            // Initialize points object with missing properties
            Object.keys(BODY_PARTS).forEach(part => {
                variations[0].points[part] = {
                    top: null,
                    bottom: null
                };
            });

            if (extremePoints) {
                variations[0].points[partName] = {
                    top: extremePoints.top,
                    bottom: extremePoints.bottom
                };
            }

            resolve(variations);
        };
    });
}



document.getElementById('visualizeBtn1').addEventListener('click', () => {
    

console.log("visual button clicked");
startProcessing1('visualize');});

document.getElementById('visualizeBtn').addEventListener('click', () => {startProcessing('visualize');});
document.getElementById('keypointsButton').addEventListener('click', handcode);
document.getElementById('legButton').addEventListener('click', legcode);
document.getElementById('legButton1').addEventListener('click', legfootcode);
document.getElementById('legButton2').addEventListener('click', rightfootcode);
document.getElementById('leftlegonlyid').addEventListener('click', leftlegonly);
document.getElementById('rightlegonlyid').addEventListener('click', rightlegonly);
document.getElementById('rightarmonlyid').addEventListener('click', rightarmonly);
document.getElementById('leftarmonlyid').addEventListener('click', leftarmonly);


async function prepareSegmentation() {
    const img = document.getElementById('sourceImage');
    segmentationResult = await net.segmentPersonParts(img);
    // alert(segmentationResult)
}

const segmentationWorker = new Worker('keypoints-worker.js');
let collectedPoints = new Map();

async function handcode() {

    const img = document.getElementById('sourceImage');
    const mainContainer = document.getElementById('mainContainer');
    mainContainer.innerHTML = '';

    const imageGrid = document.createElement('div');
    imageGrid.className = 'image-grid';

    const segmentation = segmentationResult;
    const bodyPartImages = {};
    // collectedPoints.clear();

    for (let partId = 0; partId < 24; partId++) {
        const partName = Object.keys(BODY_PARTS)[partId];
        if (!partName) continue;
        if (!segmentation.data.includes(partId)) {

            continue; 
        }

        const segmentCanvas = document.createElement('canvas');
        segmentCanvas.width = img.width;
        segmentCanvas.height = img.height;
        // const segmentCtx = segmentCanvas.getContext('2d');
        const segmentCtx = segmentCanvas.getContext('2d', { willReadFrequently: true });
        segmentCtx.drawImage(img, 0, 0);

        const imageData = segmentCtx.getImageData(0, 0, img.width, img.height);
      
        for (let i = 0; i < segmentation.data.length; i++) {
            if (segmentation.data[i] !== partId) imageData.data[i * 4 + 3] = 0;
        }

        const variations = await processSegmentVariations(imageData, partName);
        bodyPartImages[partName] = variations.map(v => ({
            imageData: v.data,
            width: img.width,
            height: img.height,
            extremePoints: v.extremePoints
        }));
    }
    
    const pointsToProcess = {
        leftFace: collectedPoints.get('left_face'),
        rightFace: collectedPoints.get('right_face'),
        leftUpperArmFront: collectedPoints.get('left_upper_arm_front'),
        leftUpperArmBack: collectedPoints.get('left_upper_arm_back'),
        leftLowerArmFront: collectedPoints.get('left_lower_arm_front'),
        leftLowerArmBack: collectedPoints.get('left_lower_arm_back'),
        leftHand: collectedPoints.get('left_hand'),
        rightUpperArmFront: collectedPoints.get('right_upper_arm_front'),
        rightUpperArmBack: collectedPoints.get('right_upper_arm_back'),
        rightLowerArmFront: collectedPoints.get('right_lower_arm_front'),
        rightLowerArmBack: collectedPoints.get('right_lower_arm_back'),
        rightHand: collectedPoints.get('right_hand'),
        torsoFront: collectedPoints.get('torso_front'),
        torsoBack: collectedPoints.get('torso_back'),
        leftUpperLegFront: collectedPoints.get('left_upper_leg_front'),
        leftUpperLegBack: collectedPoints.get('left_upper_leg_back'),
        leftLowerLegFront: collectedPoints.get('left_lower_leg_front'),
        leftLowerLegBack: collectedPoints.get('left_lower_leg_back'),
        rightUpperLegFront: collectedPoints.get('right_upper_leg_front'),
        rightUpperLegBack: collectedPoints.get('right_upper_leg_back'),
        rightLowerLegFront: collectedPoints.get('right_lower_leg_front'),
        rightLowerLegBack: collectedPoints.get('right_lower_leg_back'),
        leftFoot: collectedPoints.get('left_foot'),
        rightFoot: collectedPoints.get('right_foot')
    };

    segmentationWorker.postMessage({
        type: 'calculateAverage',
        points: pointsToProcess,
        bodyPartImages,
        partNames: {
            leftUpperArmFront: 'left_upper_arm_front',
            leftUpperArmBack: 'left_upper_arm_back',
            leftLowerArmFront: 'left_lower_arm_front',
            leftLowerArmBack: 'left_lower_arm_back',
            leftHand: 'left_hand',
            rightUpperArmFront: 'right_upper_arm_front',
            rightUpperArmBack: 'right_upper_arm_back',
            rightLowerArmFront: 'right_lower_arm_front',
            rightLowerArmBack: 'right_lower_arm_back',
            rightHand: 'right_hand',
            leftFoot: 'left_foot',
            rightFoot: 'right_foot',
            leftUpperFoot: 'left_upper_foot',
            leftLowerFoot: 'left_lower_foot',
            rightUpperFoot: 'right_upper_foot',
            rightLowerFoot: 'right_lower_foot',
            leftUpperLegFront: 'left_upper_leg_front',
            leftUpperLegBack: 'left_upper_leg_back',
            leftLowerLegFront: 'left_lower_leg_front',
            leftLowerLegBack: 'left_lower_leg_back',
            rightUpperLegFront: 'right_upper_leg_front',
            rightUpperLegBack: 'right_upper_leg_back',
            rightLowerLegFront: 'right_lower_leg_front',
            rightLowerLegBack: 'right_lower_leg_back'
        },
        offset: { x: 100, y: 50 },
        imageArray
    }); 

    segmentationWorker.onmessage = e => {
        const { type, averages, extremePoints, partNames } = e.data;
        // console.log(e.data);
        if (type === 'combinedResults' && (averages || extremePoints)) {
            
            processedData = {
                averages,
                extremePoints,
                partNames,
                timestamp: Date.now()
            };

            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            // const ctx = canvas.getContext('2d');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(img, 0, 0);

        const wrapper = document.createElement('div');
        wrapper.className = 'image-wrapper';
        wrapper.id = "wrapperid";
        wrapper.appendChild(canvas);
        canvas.id = "canvasid1";
        wrapper.appendChild(document.createElement('div')).className = 'keypoints-label';
        mainContainer.appendChild(wrapper);

// Determine which workers to use based on extreme points
const handParts = [
    'leftHand', 'rightHand', 
    'leftUpperArmFront', 'leftUpperArmBack', 
    'leftLowerArmFront', 'leftLowerArmBack',
    'rightUpperArmFront', 'rightUpperArmBack', 
    'rightLowerArmFront', 'rightLowerArmBack'
];

// Check if any hand parts are present
const hasHandParts = handParts.some(part => 
    extremePoints[part] && 
    Object.keys(extremePoints[part]).length > 0
);

// Create workers conditionally
const workersToUse = [];
if (hasHandParts) {
    const postprocessingWorker = new Worker('handworker.js');
    workersToUse.push({
        worker: postprocessingWorker,
        type: 'hand'
    });
}

numberOfVariations = document.getElementById('imageCount').value;

const workerMessages = workersToUse.map(({type}) => ({
    type: e.data.type,
    imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),
    width: canvas.width,
    height: canvas.height,
    extremePoints,
    averages,
    timestamp: Date.now(),
    partNames,
    numberOfVariations, 
    bodyPartImages,
    rotationAngles: [0, 45, 90, 135, 180],
    imageArray
}));

let accumulatedVariations = [];

let totalVariationsExpected = numberOfVariations;

let totalworkerimages = 2 * numberOfVariations;

const generatedImages = [];
let combinedImagesProcessed = 0;

// Track already processed pairs
const processedPairs = new Set();

function attemptCombination() {
    for (let i = 0; i < totalworkerimages; i += 2) {
        // Stop if we already have the required number of combined images
        if (combinedImagesProcessed >= numberOfVariations) {
            break;
        }

        // Check if the pair has already been processed
        const pairKey = `${i}-${i + 1}`;
        if (generatedImages.length >= i + 2 && !processedPairs.has(pairKey)) {
            combineImagesByIndexes(i, i + 1); // Combine images in pairs
            processedPairs.add(pairKey); // Mark the pair as processed
            combinedImagesProcessed++;
        }
    }
}


const originalPush = generatedImages.push;
generatedImages.push = function (...args) {
    originalPush.apply(this, args);
    attemptCombination(); // Check if combinations can be processed
};

function safelyCombineImages(img1, img2) {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = img1.width;
        canvas.height = img1.height;

        ctx.drawImage(img1, 0, 0);

        ctx.globalAlpha = 1;

        const x = (canvas.width - img2.width) / 2;
        const y = (canvas.height - img2.height) / 2;
        ctx.drawImage(img2, x, y);

        ctx.globalAlpha = 1;

        const combinedImg = new Image();
        combinedImg.onload = () => resolve(combinedImg);
        combinedImg.onerror = reject;
        combinedImg.src = canvas.toDataURL();
    });
}

function combineImagesByIndexes(index1, index2) {
    const firstImageType = generatedImages[index1].type;
    const secondImageType = generatedImages[index2].type;

    // console.log(`Attempting to combine - First Type: ${firstImageType}, Second Type: ${secondImageType}`);

    // Prevent combination if types are the same
    if (firstImageType === secondImageType) {
        console.error(`Cannot combine images of the same type: ${firstImageType}`);
        return; // Exit the function immediately
    }

    if (generatedImages.length > Math.max(index1, index2)) {
        const imagePromises = [index1, index2].map(idx => {
            return new Promise((resolve, reject) => {
                const imgInfo = generatedImages[idx];
                const img = new Image();

                if (imgInfo.imageUrl) {
                    img.src = imgInfo.imageUrl;
                } else {
                    try {
                        img.src = createImageFromData(
                            imgInfo.imageData,
                            imgInfo.width,
                            imgInfo.height
                        );
                    } catch (error) {
                        console.error('Error creating image:', error);
                        reject(error);
                        return;
                    }
                }

                img.onload = () => resolve(img);
                img.onerror = reject;
            });
        });

        Promise.all(imagePromises)
            .then(([img1, img2]) => safelyCombineImages(img1, img2))
            .then(combinedImg => {
                const combinedContainer = document.createElement('div');
                combinedContainer.className = 'combined-images-container';

                const combinedWrapper = document.createElement('div');
                combinedWrapper.className = 'image-wrapper combined';
                combinedWrapper.appendChild(combinedImg);

                const verificationInfo = document.createElement('div');
                verificationInfo.className = 'verification-info';
                verificationInfo.innerHTML = `
                    Combination Verification:
                    <br>First Image Type: ${generatedImages[index1].type}
                    <br>Second Image Type: ${generatedImages[index2].type}
                    <br>First Image Dimensions: ${generatedImages[index1].width}x${generatedImages[index1].height}
                    <br>Second Image Dimensions: ${generatedImages[index2].width}x${generatedImages[index2].height}
                    <br>Combined Image Dimensions: ${combinedImg.width}x${combinedImg.height}
                `;

                combinedContainer.appendChild(verificationInfo);
                combinedContainer.appendChild(combinedWrapper);

                const container = document.getElementById('imageContainer');
                container.appendChild(combinedContainer);

                // console.log(`Images at indexes ${index1} and ${index2} combined successfully`);
            })
            .catch(error => {
                console.error(`Error combining images at indexes ${index1} and ${index2}:`, error);

                const errorContainer = document.createElement('div');
                errorContainer.className = 'verification-info';
                errorContainer.textContent = `Error combining images: ${error.message}`;

                const container = document.getElementById('imageContainer');
                container.appendChild(errorContainer);
            });
      
        }
}


const imageContainer = document.getElementById('imageContainer');
imageContainer.innerHTML = ''; // Clear existing content
imageContainer.style.position = 'relative';
imageContainer.style.height = '600px'; // Adjust as needed
imageContainer.style.overflow = 'hidden';

// Add styles
const style = document.createElement('style');
style.textContent = `
    #imageContainer {
        position: relative;
        width: 100%;
        margin: 20px 0;
        overflow: hidden;
    }

    .image-wrapper {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
    }

    .image-wrapper.active {
        opacity: 1;
    }

    .image-wrapper img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }
`;
document.head.appendChild(style);

// Promise.allSettled code remains the same
Promise.allSettled(
    workersToUse.map(({ worker }, index) =>
        new Promise((resolve, reject) => {
            worker.onmessage = (e) => {
                if (e.data.type === 'processedVariations') {
                    if (!e.data.variations || e.data.variations.length === 0) {
                        console.warn(`No variations for ${workersToUse[index].type} worker`);
                        return;
                    }

                    workersToUse[index].variations = e.data.variations;

                    e.data.variations.forEach((variation, variationIndex) => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'image-wrapper';
                        
                        const img = document.createElement('img');
                        img.src = variation.imageUrl || createImageFromData(
                            variation.imageData,
                            variation.width,
                            variation.height
                        );

                        wrapper.appendChild(img);
                        imageContainer.appendChild(wrapper);

                        generatedImages.push({
                            index: variationIndex,
                            type: workersToUse[index].type,
                            wrapper: wrapper,
                            image: img
                        });
                    });

                    // Start animation when all workers are done
                    if (index === workersToUse.length - 1) {
                        startSequentialAnimation();
                    }

                    resolve({
                        type: workersToUse[index].type,
                        variations: e.data.variations
                    });
                }
            };

            worker.onerror = (error) => {
                console.error('Worker error:', error);
                reject(error);
            };

            worker.postMessage(workerMessages[index]);
        })
    )
).catch(error => {
    console.error('Overall worker processing error:', error);
});

// Modified sequential animation function for continuous animation
function startSequentialAnimation() {
    let currentIndex = 0;
    
    // First hide all images
    generatedImages.forEach(item => {
        item.wrapper.classList.remove('active');
    });

    function showNextImage() {
        // Hide current image
        if (currentIndex > 0) {
            generatedImages[currentIndex - 1].wrapper.classList.remove('active');
        } else {
            // When starting a new cycle, hide the last image
            generatedImages[generatedImages.length - 1].wrapper.classList.remove('active');
        }

        // Show next image
        generatedImages[currentIndex].wrapper.classList.add('active');

        // Increment counter
        currentIndex = (currentIndex + 1) % generatedImages.length;

        // Schedule next image - animation continues indefinitely
        setTimeout(showNextImage, 200);
    }

    // Start the sequence
    showNextImage();
}

    // Helper function to create an image from ImageData
    function createImageFromData(imageData, width, height) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.putImageData(new ImageData(imageData, width, height), 0, 0);
        return canvas.toDataURL();
    }


        }
    
    
    }


}

async function legcode() {

const img = document.getElementById('sourceImage');
const mainContainer = document.getElementById('mainContainer');
mainContainer.innerHTML = '';
if (!window.imageArray) {
        window.imageArray = [];
    }
    
    // Push the current image to the array
    window.imageArray.push(img);
const imageGrid = document.createElement('div');
imageGrid.className = 'image-grid';

const segmentation = segmentationResult;
const bodyPartImages = {};
// collectedPoints.clear();

for (let partId = 0; partId < 24; partId++) {
    const partName = Object.keys(BODY_PARTS)[partId];
    if (!partName) continue;
    if (!segmentation.data.includes(partId)) {

        continue; 
    
    }

    const segmentCanvas = document.createElement('canvas');
    segmentCanvas.width = img.width;
    segmentCanvas.height = img.height;
    // const segmentCtx = segmentCanvas.getContext('2d');
    const segmentCtx = segmentCanvas.getContext('2d', { willReadFrequently: true });
    segmentCtx.drawImage(img, 0, 0);

    const imageData = segmentCtx.getImageData(0, 0, img.width, img.height);
  
    for (let i = 0; i < segmentation.data.length; i++) {
        if (segmentation.data[i] !== partId) imageData.data[i * 4 + 3] = 0;
    }

    const variations = await processSegmentVariations(imageData, partName);
    bodyPartImages[partName] = variations.map(v => ({
        imageData: v.data,
        width: img.width,
        height: img.height,
        extremePoints: v.extremePoints
    }));
}

const pointsToProcess = {
    leftFace: collectedPoints.get('left_face'),
    rightFace: collectedPoints.get('right_face'),
    leftUpperArmFront: collectedPoints.get('left_upper_arm_front'),
    leftUpperArmBack: collectedPoints.get('left_upper_arm_back'),
    leftLowerArmFront: collectedPoints.get('left_lower_arm_front'),
    leftLowerArmBack: collectedPoints.get('left_lower_arm_back'),
    leftHand: collectedPoints.get('left_hand'),
    rightUpperArmFront: collectedPoints.get('right_upper_arm_front'),
    rightUpperArmBack: collectedPoints.get('right_upper_arm_back'),
    rightLowerArmFront: collectedPoints.get('right_lower_arm_front'),
    rightLowerArmBack: collectedPoints.get('right_lower_arm_back'),
    rightHand: collectedPoints.get('right_hand'),
    torsoFront: collectedPoints.get('torso_front'),
    torsoBack: collectedPoints.get('torso_back'),
    leftUpperLegFront: collectedPoints.get('left_upper_leg_front'),
    leftUpperLegBack: collectedPoints.get('left_upper_leg_back'),
    leftLowerLegFront: collectedPoints.get('left_lower_leg_front'),
    leftLowerLegBack: collectedPoints.get('left_lower_leg_back'),
    rightUpperLegFront: collectedPoints.get('right_upper_leg_front'),
    rightUpperLegBack: collectedPoints.get('right_upper_leg_back'),
    rightLowerLegFront: collectedPoints.get('right_lower_leg_front'),
    rightLowerLegBack: collectedPoints.get('right_lower_leg_back'),
    leftFoot: collectedPoints.get('left_foot'),
    rightFoot: collectedPoints.get('right_foot')
};

segmentationWorker.postMessage({
    type: 'calculateAverage',
    points: pointsToProcess,
    bodyPartImages,
    partNames: {
        leftUpperArmFront: 'left_upper_arm_front',
        leftUpperArmBack: 'left_upper_arm_back',
        leftLowerArmFront: 'left_lower_arm_front',
        leftLowerArmBack: 'left_lower_arm_back',
        leftHand: 'left_hand',
        rightUpperArmFront: 'right_upper_arm_front',
        rightUpperArmBack: 'right_upper_arm_back',
        rightLowerArmFront: 'right_lower_arm_front',
        rightLowerArmBack: 'right_lower_arm_back',
        rightHand: 'right_hand',
        leftFoot: 'left_foot',
        rightFoot: 'right_foot',
        leftUpperFoot: 'left_upper_foot',
        leftLowerFoot: 'left_lower_foot',
        rightUpperFoot: 'right_upper_foot',
        rightLowerFoot: 'right_lower_foot',
        leftUpperLegFront: 'left_upper_leg_front',
        leftUpperLegBack: 'left_upper_leg_back',
        leftLowerLegFront: 'left_lower_leg_front',
        leftLowerLegBack: 'left_lower_leg_back',
        rightUpperLegFront: 'right_upper_leg_front',
        rightUpperLegBack: 'right_upper_leg_back',
        rightLowerLegFront: 'right_lower_leg_front',
        rightLowerLegBack: 'right_lower_leg_back'
    },
    offset: { x: 100, y: 50 },
    imageArray
}); 

segmentationWorker.onmessage = e => {
    const { type, averages, extremePoints, partNames } = e.data;

    // console.log(e.data);
    if (type === 'combinedResults' && (averages || extremePoints)) {
        
        processedData = {
            averages,
            extremePoints,
            partNames,
            timestamp: Date.now()
        };

        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;

        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.drawImage(img, 0, 0);

        const wrapper = document.createElement('div');
        wrapper.className = 'image-wrapper';
        wrapper.id = "wrapperid";
        wrapper.appendChild(canvas);
        canvas.id = "canvasid1";
        wrapper.appendChild(document.createElement('div')).className = 'keypoints-label';
        mainContainer.appendChild(wrapper);

const legParts = [
    'leftFoot', 'rightFoot',
    'leftUpperLegFront', 'leftUpperLegBack', 
    'leftLowerLegFront', 'leftLowerLegBack',
    'rightUpperLegFront', 'rightUpperLegBack', 
    'rightLowerLegFront', 'rightLowerLegBack'
];

// Check if any leg parts are present
const hasLegParts = legParts.some(part => 
    extremePoints[part] && 
    Object.keys(extremePoints[part]).length > 0
);

// Create workers conditionally
const workersToUse = [];
if (hasLegParts) {
    const legWorker = new Worker('legworker.js');
    workersToUse.push({
        worker: legWorker,
        type: 'leg'
    });
}

numberOfVariations = document.getElementById('imageCount').value;

const workerMessages = workersToUse.map(({type}) => ({
    type: e.data.type,
    imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),
    width: canvas.width,
    height: canvas.height,
    extremePoints,
    averages,
    timestamp: Date.now(),
    partNames,
    numberOfVariations, 
    bodyPartImages,
    rotationAngles: [0, 45, 90, 135, 180],
    imageArray
}));

let accumulatedVariations = [];

let totalVariationsExpected = numberOfVariations;

let totalworkerimages = 2 * numberOfVariations;

// const generatedImages = [];
let combinedImagesProcessed = 0;

// Track already processed pairs
const processedPairs = new Set();

function attemptCombination() {
    for (let i = 0; i < totalworkerimages; i += 2) {
        // Stop if we already have the required number of combined images
        if (combinedImagesProcessed >= numberOfVariations) {
            break;
        }

        // Check if the pair has already been processed
        const pairKey = `${i}-${i + 1}`;
        if (generatedImages.length >= i + 2 && !processedPairs.has(pairKey)) {
            combineImagesByIndexes(i, i + 1); // Combine images in pairs
            processedPairs.add(pairKey); // Mark the pair as processed
            combinedImagesProcessed++;
        }
    }
}


const originalPush = generatedImages.push;
generatedImages.push = function (...args) {
    originalPush.apply(this, args);
    attemptCombination(); // Check if combinations can be processed
};

function safelyCombineImages(img1, img2) {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = img1.width;
        canvas.height = img1.height;

        ctx.drawImage(img1, 0, 0);

        ctx.globalAlpha = 1;

        const x = (canvas.width - img2.width) / 2;
        const y = (canvas.height - img2.height) / 2;
        ctx.drawImage(img2, x, y);

        ctx.globalAlpha = 1;

        const combinedImg = new Image();
        combinedImg.onload = () => resolve(combinedImg);
        combinedImg.onerror = reject;
        combinedImg.src = canvas.toDataURL();
    });
}

function combineImagesByIndexes(index1, index2) {
    const firstImageType = generatedImages[index1].type;
    const secondImageType = generatedImages[index2].type;

    // console.log(`Attempting to combine - First Type: ${firstImageType}, Second Type: ${secondImageType}`);

    // Prevent combination if types are the same
    if (firstImageType === secondImageType) {
        console.error(`Cannot combine images of the same type: ${firstImageType}`);
        return; // Exit the function immediately
    }

    if (generatedImages.length > Math.max(index1, index2)) {
        const imagePromises = [index1, index2].map(idx => {
            return new Promise((resolve, reject) => {
                const imgInfo = generatedImages[idx];
                const img = new Image();

                if (imgInfo.imageUrl) {
                    img.src = imgInfo.imageUrl;
                } else {
                    try {
                        img.src = createImageFromData(
                            imgInfo.imageData,
                            imgInfo.width,
                            imgInfo.height
                        );
                    } catch (error) {
                        console.error('Error creating image:', error);
                        reject(error);
                        return;
                    }
                }

                img.onload = () => resolve(img);
                img.onerror = reject;
            });
        });

        const imageContainer = document.getElementById('imageContainer');
imageContainer.innerHTML = ''; // Clear existing content
imageContainer.style.position = 'relative';
imageContainer.style.height = '600px'; // Adjust as needed
imageContainer.style.overflow = 'hidden';

// Add styles
const style = document.createElement('style');
style.textContent = `
    #imageContainer {
        position: relative;
        width: 100%;
        margin: 20px 0;
        overflow: hidden;
    }

    .image-wrapper {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
    }

    .image-wrapper.active {
        opacity: 1;
    }

    .image-wrapper img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }
`;

document.head.appendChild(style);

// Promise.allSettled code remains the same
Promise.allSettled(
    workersToUse.map(({ worker }, index) =>
        new Promise((resolve, reject) => {
            worker.onmessage = (e) => {
                if (e.data.type === 'processedVariations') {
                    if (!e.data.variations || e.data.variations.length === 0) {
                        console.warn(`No variations for ${workersToUse[index].type} worker`);
                        return;
                    }

                    workersToUse[index].variations = e.data.variations;

                    e.data.variations.forEach((variation, variationIndex) => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'image-wrapper';
                        
                        const img = document.createElement('img');
                        img.src = variation.imageUrl || createImageFromData(
                            variation.imageData,
                            variation.width,
                            variation.height
                        );

                        wrapper.appendChild(img);
                        imageContainer.appendChild(wrapper);

                        generatedImages.push({
                            index: variationIndex,
                            type: workersToUse[index].type,
                            wrapper: wrapper,
                            image: img
                        });
                    });

                    // Start animation when all workers are done
                    if (index === workersToUse.length - 1) {
                        startSequentialAnimation();
                    }

                    resolve({
                        type: workersToUse[index].type,
                        variations: e.data.variations
                    });
                }
            };

            worker.onerror = (error) => {
                console.error('Worker error:', error);
                reject(error);
            };

            worker.postMessage(workerMessages[index]);
        })
    )
).catch(error => {
    console.error('Overall worker processing error:', error);
});

        }
}

    const canvasImages = [];
    function convertImageDataToUrl(imageData, width, height) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        
        const ctx = canvas.getContext('2d');
        const imgDataObj = new ImageData(imageData, width, height);
        
        ctx.putImageData(imgDataObj, 0, 0);
        return canvas.toDataURL('image/png');
    }

    function displayImagesOnCanvases() {
    // Clear previous canvas images
    canvasImages.length = 0;

    // Get the container for canvases
    const canvasContainer = document.getElementById('canvasContainer');
    canvasContainer.innerHTML = ''; // Clear previous canvases

    generatedImages.forEach((imageData, index) => {
        // Create a wrapper div for each canvas
        const wrapper = document.createElement('div');
        wrapper.className = 'canvas-wrapper';

        // Create canvas element
        const canvas = document.createElement('canvas');
        canvas.width = imageData.width;
        canvas.height = imageData.height;
        canvas.id = `canvas-${index}`;

        // Get canvas context
        const ctx = canvas.getContext('2d');

        // Create an image element to draw on canvas
        const img = new Image();
        img.onload = function() {
            ctx.drawImage(img, 0, 0, imageData.width, imageData.height);
            
            const canvasImageData = ctx.getImageData(0, 0, imageData.width, imageData.height);

            const effectWorker = new Worker('js/running2Worker.js');
        // effectWorker.onmessage = (effectEvent) => {
        //     // Process the modified image data
        //     const modifiedCanvas = document.createElement('canvas');
        //     modifiedCanvas.width = imageData.width;
        //     modifiedCanvas.height = imageData.height;
        //     const modifiedCtx = modifiedCanvas.getContext('2d');
        //     // alert(modifiedCanvas)
            
        //     // Create a new ImageData from the worker's result
        //     modifiedCtx.putImageData(effectEvent.data.imageData, 0, 0);
            
        //     // Create an image from the modified canvas
        //     const modifiedImg = new Image();
        //     modifiedImg.src = modifiedCanvas.toDataURL('image/png');
            
        //                         // Create wrapper and display
        //                         const wrapper = document.createElement('div');
        //                         wrapper.className = 'image-wrapper1';
        //                         wrapper.appendChild(modifiedImg);

        //                         const container = document.getElementById('imageContainer');
        //                         container.appendChild(wrapper);

        //                         // Store in generatedImages
        //                         generatedImages.push({ 
        //                             index: variationIndex, 
        //                             type: workersToUse[index].type, 
        //                             image: modifiedImg, 
        //                             imageUrl: modifiedImg.src, 
        //                             imageData: effectEvent.data.imageData.data, 
        //                             width: variation.width, 
        //                             height: variation.height 
        //                         });

        //                         displayImagesOnCanvases();
        //                     };

                            
            canvasImages.push({
                canvas: canvas,
                imageData: imageData
            });
        };
        img.src = imageData.imageUrl;

        // Create info paragraph
        const infoP = document.createElement('p');
        infoP.textContent = `Canvas ${index + 1} - Type: ${imageData.type}, Width: ${imageData.width}, Height: ${imageData.height}`;

        // Append canvas and info to wrapper
        // wrapper.appendChild(canvas);
        // wrapper.appendChild(infoP);

        // Add wrapper to container
        // canvasContainer.appendChild(wrapper);
    });

}


const imageContainer = document.getElementById('imageContainer');
imageContainer.innerHTML = ''; // Clear existing content
imageContainer.style.position = 'relative';
imageContainer.style.height = '600px'; // Adjust as needed
imageContainer.style.overflow = 'hidden';

// Add styles
const style = document.createElement('style');
style.textContent = `
    #imageContainer {
        position: relative;
        width: 100%;
        margin: 20px 0;
        overflow: hidden;
    }

    .image-wrapper {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        }

    .image-wrapper.active {
        opacity: 1;
    }

    .image-wrapper img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }
`;
document.head.appendChild(style);

// Promise.allSettled code remains the same
Promise.allSettled(
    workersToUse.map(({ worker }, index) =>
        new Promise((resolve, reject) => {
            worker.onmessage = (e) => {
                if (e.data.type === 'processedVariations') {
                    if (!e.data.variations || e.data.variations.length === 0) {
                        console.warn(`No variations for ${workersToUse[index].type} worker`);
                        return;
                    }

                    workersToUse[index].variations = e.data.variations;

                    e.data.variations.forEach((variation, variationIndex) => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'image-wrapper';
                        
                        const img = document.createElement('img');
                        img.src = variation.imageUrl || createImageFromData(
                            variation.imageData,
                            variation.width,
                            variation.height
                        );

                        wrapper.appendChild(img);
                        imageContainer.appendChild(wrapper);

                        generatedImages.push({
                            index: variationIndex,
                            type: workersToUse[index].type,
                            wrapper: wrapper,
                            image: img
                        });
                    });

                    // Start animation when all workers are done
                    if (index === workersToUse.length - 1) {
                        startSequentialAnimation();
                    }

                    resolve({
                        type: workersToUse[index].type,
                        variations: e.data.variations
                    });
                }
            };

            worker.onerror = (error) => {
                console.error('Worker error:', error);
                reject(error);
            };

            worker.postMessage(workerMessages[index]);
        })
    )
).catch(error => {
    console.error('Overall worker processing error:', error);
});

// Modified sequential animation function for continuous animation
function startSequentialAnimation() {
    let currentIndex = 0;
    
    // First hide all images
    generatedImages.forEach(item => {
        item.wrapper.classList.remove('active');
    });

    function showNextImage() {
        // Hide current image
        if (currentIndex > 0) {
            generatedImages[currentIndex - 1].wrapper.classList.remove('active');
        } else {
            // When starting a new cycle, hide the last image
            generatedImages[generatedImages.length - 1].wrapper.classList.remove('active');
        }

        // Show next image
        generatedImages[currentIndex].wrapper.classList.add('active');

        // Increment counter
        currentIndex = (currentIndex + 1) % generatedImages.length;

        // Schedule next image - animation continues indefinitely
        setTimeout(showNextImage, 200);
    }

    // Start the sequence
    showNextImage();
}
    // // Worker processing
    // Promise.allSettled(
    //     workersToUse.map(({ worker }, index) =>
    //         new Promise((resolve, reject) => {
    //             worker.onmessage = (e) => {
    //                 if (e.data.type === 'processedVariations') {
    //                     if (!e.data.variations || e.data.variations.length === 0) {
    //                         console.warn(`No variations for ${workersToUse[index].type} worker`);
    //                         return;
    //                     }

    //                     workersToUse[index].variations = e.data.variations;

    //                     e.data.variations.forEach((variation, variationIndex) => {
    //                         const img = document.createElement('img');
    //                         img.src = variation.imageUrl || createImageFromData(
    //                             variation.imageData,
    //                             variation.width,
    //                             variation.height
    //                         );
                            
    //                         const wrapper = document.createElement('div');
    //                         wrapper.className = 'image-wrapper1';

    //                         wrapper.appendChild(img);

    //                         const container = document.getElementById('imageContainer');
    //                         container.appendChild(wrapper);
        
    //         function convertImageDataToUrl(imageData, width, height) {
    //             // Create a canvas to draw the image data
    //             const canvas = document.createElement('canvas');
    //             canvas.width = width;
    //             canvas.height = height;
                
    //             // Get the canvas context
    //             const ctx = canvas.getContext('2d');
                
    //             // Create an ImageData object from the Uint8ClampedArray
    //             const imgData = new ImageData(imageData, width, height);
                
    //             // Draw the image data on the canvas
    //             ctx.putImageData(imgData, 0, 0);
                
    //             // Convert the canvas to a data URL
    //             return canvas.toDataURL('image/png');
    //         }
                
    //     const imageUrl = convertImageDataToUrl(variation.imageData, variation.width, variation.height);

    //     // Store image data in generatedImages array
    //     generatedImages.push({ 
    //         index: variationIndex, 
    //         type: workersToUse[index].type, 
    //         image: img, 
    //         imageUrl: imageUrl, 
    //         imageData: variation.imageData, 
    //         width: variation.width, 
    //         height: variation.height 
    //     });
    //     displayImagesOnCanvases();



    // function displayGeneratedImages() {
    //     const imageDisplay = document.getElementById('imageDisplay');
    //     imageDisplay.innerHTML = ''; // Clear previous images

    //     generatedImages.forEach((imageData, index) => {
    //         const imageContainer = document.createElement('div');
    //         imageContainer.classList.add('image-item');

    //         const imgElement = document.createElement('img');
            
    //         // Use the created imageUrl
    //         imgElement.src = imageData.imageUrl;

    //         const infoP = document.createElement('p');
    //         infoP.textContent = `Image ${index + 1} - Type: ${imageData.type}, Width: ${imageData.width}, Height: ${imageData.height}`;

    //         imageContainer.appendChild(imgElement);
    //         imageContainer.appendChild(infoP);
    //         imageDisplay.appendChild(imageContainer);
    //     });

    //     // console.log('Generated Images:', generatedImages);
    // }
    //     });

    //                     resolve({
    //                         type: workersToUse[index].type,
    //                         variations: e.data.variations
    //                     });
                
    //                 }
    //             };

    //             worker.onerror = (error) => {
    //                 console.error('Worker error:', error);
    //                 reject(error);
    //             };

    //             worker.postMessage(workerMessages[index]);
    //         })
    //     )
    // ).catch(error => {
    //     console.error('Overall worker processing error:', error);
    // });

    // Helper function to create an image from ImageData
    function createImageFromData(imageData, width, height) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.putImageData(new ImageData(imageData, width, height), 0, 0);
        return canvas.toDataURL();
    }


    }


}
}

async function legfootcode() {
// console.log("button clicked");

const img = document.getElementById('sourceImage');
const mainContainer = document.getElementById('mainContainer');
mainContainer.innerHTML = '';

const imageGrid = document.createElement('div');
imageGrid.className = 'image-grid';

const segmentation = segmentationResult;
const bodyPartImages = {};
// collectedPoints.clear();

for (let partId = 0; partId < 24; partId++) {
    const partName = Object.keys(BODY_PARTS)[partId];
    if (!partName) continue;
    if (!segmentation.data.includes(partId)) {

        continue; 
    
    }

    const segmentCanvas = document.createElement('canvas');
    segmentCanvas.width = img.width;
    segmentCanvas.height = img.height;
    const segmentCtx = segmentCanvas.getContext('2d', { willReadFrequently: true });
    segmentCtx.drawImage(img, 0, 0);

    const imageData = segmentCtx.getImageData(0, 0, img.width, img.height);
  
    for (let i = 0; i < segmentation.data.length; i++) {
        if (segmentation.data[i] !== partId) imageData.data[i * 4 + 3] = 0;
    }

    const variations = await processSegmentVariations(imageData, partName);
    bodyPartImages[partName] = variations.map(v => ({
        imageData: v.data,
        width: img.width,
        height: img.height,
        extremePoints: v.extremePoints
    }));
}

const pointsToProcess = {
    leftFace: collectedPoints.get('left_face'),
    rightFace: collectedPoints.get('right_face'),
    leftUpperArmFront: collectedPoints.get('left_upper_arm_front'),
    leftUpperArmBack: collectedPoints.get('left_upper_arm_back'),
    leftLowerArmFront: collectedPoints.get('left_lower_arm_front'),
    leftLowerArmBack: collectedPoints.get('left_lower_arm_back'),
    leftHand: collectedPoints.get('left_hand'),
    rightUpperArmFront: collectedPoints.get('right_upper_arm_front'),
    rightUpperArmBack: collectedPoints.get('right_upper_arm_back'),
    rightLowerArmFront: collectedPoints.get('right_lower_arm_front'),
    rightLowerArmBack: collectedPoints.get('right_lower_arm_back'),
    rightHand: collectedPoints.get('right_hand'),
    torsoFront: collectedPoints.get('torso_front'),
    torsoBack: collectedPoints.get('torso_back'),
    leftUpperLegFront: collectedPoints.get('left_upper_leg_front'),
    leftUpperLegBack: collectedPoints.get('left_upper_leg_back'),
    leftLowerLegFront: collectedPoints.get('left_lower_leg_front'),
    leftLowerLegBack: collectedPoints.get('left_lower_leg_back'),
    rightUpperLegFront: collectedPoints.get('right_upper_leg_front'),
    rightUpperLegBack: collectedPoints.get('right_upper_leg_back'),
    rightLowerLegFront: collectedPoints.get('right_lower_leg_front'),
    rightLowerLegBack: collectedPoints.get('right_lower_leg_back'),
    leftFoot: collectedPoints.get('left_foot'),
    rightFoot: collectedPoints.get('right_foot')
};

segmentationWorker.postMessage({
    type: 'calculateAverage',
    points: pointsToProcess,
    bodyPartImages,
    partNames: {
        leftUpperArmFront: 'left_upper_arm_front',
        leftUpperArmBack: 'left_upper_arm_back',
        leftLowerArmFront: 'left_lower_arm_front',
        leftLowerArmBack: 'left_lower_arm_back',
        leftHand: 'left_hand',
        rightUpperArmFront: 'right_upper_arm_front',
        rightUpperArmBack: 'right_upper_arm_back',
        rightLowerArmFront: 'right_lower_arm_front',
        rightLowerArmBack: 'right_lower_arm_back',
        rightHand: 'right_hand',
        leftFoot: 'left_foot',
        rightFoot: 'right_foot',
        leftUpperFoot: 'left_upper_foot',
        leftLowerFoot: 'left_lower_foot',
        rightUpperFoot: 'right_upper_foot',
        rightLowerFoot: 'right_lower_foot',
        leftUpperLegFront: 'left_upper_leg_front',
        leftUpperLegBack: 'left_upper_leg_back',
        leftLowerLegFront: 'left_lower_leg_front',
        leftLowerLegBack: 'left_lower_leg_back',
        rightUpperLegFront: 'right_upper_leg_front',
        rightUpperLegBack: 'right_upper_leg_back',
        rightLowerLegFront: 'right_lower_leg_front',
        rightLowerLegBack: 'right_lower_leg_back'
    },
    offset: { x: 100, y: 50 },
    imageArray
}); 

segmentationWorker.onmessage = e => {
    const { type, averages, extremePoints, partNames } = e.data;
    // console.log(e.data);
    if (type === 'combinedResults' && (averages || extremePoints)) {
        
        processedData = {
            averages,
            extremePoints,
            partNames,
            timestamp: Date.now()
        };

        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        // const ctx = canvas.getContext('2d');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.drawImage(img, 0, 0);

        const wrapper = document.createElement('div');
        wrapper.className = 'image-wrapper';
        wrapper.id = "wrapperid";
        wrapper.appendChild(canvas);
        canvas.id = "canvasid1";
        wrapper.appendChild(document.createElement('div')).className = 'keypoints-label';
        mainContainer.appendChild(wrapper);

const legParts = [
    'leftFoot', 'rightFoot',
    'leftUpperLegFront', 'leftUpperLegBack', 
    'leftLowerLegFront', 'leftLowerLegBack',
    'rightUpperLegFront', 'rightUpperLegBack', 
    'rightLowerLegFront', 'rightLowerLegBack'
];

const hasLegParts = legParts.some(part => 
    extremePoints[part] && 
    Object.keys(extremePoints[part]).length > 0
);

// Create workers conditionally
const workersToUse = [];
if (hasLegParts) {
    const legWorker = new Worker('legfootworker.js');
    workersToUse.push({
        worker: legWorker,
        type: 'leg'
    });
}

numberOfVariations = document.getElementById('imageCount').value;

const workerMessages = workersToUse.map(({type}) => ({
    type: e.data.type,
    imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),
    width: canvas.width,
    height: canvas.height,
    extremePoints,
    averages,
    timestamp: Date.now(),
    partNames,
    numberOfVariations, 
    bodyPartImages,
    rotationAngles: [0, 45, 90, 135, 180],
    imageArray
}));

let accumulatedVariations = [];

let totalVariationsExpected = numberOfVariations;

let totalworkerimages = 2 * numberOfVariations;

const generatedImages = [];
let combinedImagesProcessed = 0;

// Track already processed pairs
const processedPairs = new Set();

function attemptCombination() {
    for (let i = 0; i < totalworkerimages; i += 2) {
        // Stop if we already have the required number of combined images
        if (combinedImagesProcessed >= numberOfVariations) {
            break;
        }

        // Check if the pair has already been processed
        const pairKey = `${i}-${i + 1}`;
        if (generatedImages.length >= i + 2 && !processedPairs.has(pairKey)) {
            combineImagesByIndexes(i, i + 1); // Combine images in pairs
            processedPairs.add(pairKey); // Mark the pair as processed
            combinedImagesProcessed++;
        }
    }
}

function safelyCombineImages(img1, img2) {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = img1.width;
        canvas.height = img1.height;

        ctx.drawImage(img1, 0, 0);

        ctx.globalAlpha = 1;

        const x = (canvas.width - img2.width) / 2;
        const y = (canvas.height - img2.height) / 2;
        ctx.drawImage(img2, x, y);

        ctx.globalAlpha = 1;

        const combinedImg = new Image();
        combinedImg.onload = () => resolve(combinedImg);
        combinedImg.onerror = reject;
        combinedImg.src = canvas.toDataURL();
    });
}

function combineImagesByIndexes(index1, index2) {
    const firstImageType = generatedImages[index1].type;
    const secondImageType = generatedImages[index2].type;

    // console.log(`Attempting to combine - First Type: ${firstImageType}, Second Type: ${secondImageType}`);

    // Prevent combination if types are the same
    if (firstImageType === secondImageType) {
        console.error(`Cannot combine images of the same type: ${firstImageType}`);
        return; // Exit the function immediately
    }

    if (generatedImages.length > Math.max(index1, index2)) {
        const imagePromises = [index1, index2].map(idx => {
            return new Promise((resolve, reject) => {
                const imgInfo = generatedImages[idx];
                const img = new Image();

                if (imgInfo.imageUrl) {
                    img.src = imgInfo.imageUrl;
                } else {
                    try {
                        img.src = createImageFromData(
                            imgInfo.imageData,
                            imgInfo.width,
                            imgInfo.height
                        );
                    } catch (error) {
                        console.error('Error creating image:', error);
                        reject(error);
                        return;
                    }
                }

                img.onload = () => resolve(img);
                img.onerror = reject;
            });
        });

        Promise.all(imagePromises)
            .then(([img1, img2]) => safelyCombineImages(img1, img2))
            .then(combinedImg => {
                const combinedContainer = document.createElement('div');
                combinedContainer.className = 'combined-images-container';

                const combinedWrapper = document.createElement('div');
                combinedWrapper.className = 'image-wrapper combined';
                combinedWrapper.appendChild(combinedImg);

                const verificationInfo = document.createElement('div');
                verificationInfo.className = 'verification-info';
               
               
                combinedContainer.appendChild(verificationInfo);
                combinedContainer.appendChild(combinedWrapper);

                const container = document.getElementById('imageContainer');
                container.appendChild(combinedContainer);

                // console.log(`Images at indexes ${index1} and ${index2} combined successfully`);
            })
            .catch(error => {
                console.error(`Error combining images at indexes ${index1} and ${index2}:`, error);

                const errorContainer = document.createElement('div');
                errorContainer.className = 'verification-info';
                errorContainer.textContent = `Error combining images: ${error.message}`;

                const container = document.getElementById('imageContainer');
                container.appendChild(errorContainer);
            });      
      }
}


const imageContainer = document.getElementById('imageContainer');
imageContainer.innerHTML = ''; // Clear existing content
imageContainer.style.position = 'relative';
imageContainer.style.height = '600px'; // Adjust as needed
imageContainer.style.overflow = 'hidden';

// Add styles
const style = document.createElement('style');
style.textContent = `
    #imageContainer {
        position: relative;
        width: 100%;
        margin: 20px 0;
        overflow: hidden;
    }

    .image-wrapper {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
    }

    .image-wrapper.active {
        opacity: 1;
    }

    .image-wrapper img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }
`;
document.head.appendChild(style);

// Promise.allSettled code remains the same
Promise.allSettled(
    workersToUse.map(({ worker }, index) =>
        new Promise((resolve, reject) => {
            worker.onmessage = (e) => {
                if (e.data.type === 'processedVariations') {
                    if (!e.data.variations || e.data.variations.length === 0) {
                        console.warn(`No variations for ${workersToUse[index].type} worker`);
                        return;
                    }

                    workersToUse[index].variations = e.data.variations;

                    e.data.variations.forEach((variation, variationIndex) => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'image-wrapper';
                        
                        const img = document.createElement('img');
                        img.src = variation.imageUrl || createImageFromData(
                            variation.imageData,
                            variation.width,
                            variation.height
                        );

                        wrapper.appendChild(img);
                        imageContainer.appendChild(wrapper);

                        generatedImages.push({
                            index: variationIndex,
                            type: workersToUse[index].type,
                            wrapper: wrapper,
                            image: img
                        });
                    });

                    // Start animation when all workers are done
                    if (index === workersToUse.length - 1) {
                        startSequentialAnimation();
                    }

                    resolve({
                        type: workersToUse[index].type,
                        variations: e.data.variations
                    });
                }
            };

            worker.onerror = (error) => {
                console.error('Worker error:', error);
                reject(error);
            };

            worker.postMessage(workerMessages[index]);
        })
    )
).catch(error => {
    console.error('Overall worker processing error:', error);
});

// Modified sequential animation function for continuous animation
function startSequentialAnimation() {
    let currentIndex = 0;
    
    // First hide all images
    generatedImages.forEach(item => {
        item.wrapper.classList.remove('active');
    });

    function showNextImage() {
        // Hide current image
        if (currentIndex > 0) {
            generatedImages[currentIndex - 1].wrapper.classList.remove('active');
        } else {
            // When starting a new cycle, hide the last image
            generatedImages[generatedImages.length - 1].wrapper.classList.remove('active');
        }

        // Show next image
        generatedImages[currentIndex].wrapper.classList.add('active');

        // Increment counter
        currentIndex = (currentIndex + 1) % generatedImages.length;

        // Schedule next image - animation continues indefinitely
        setTimeout(showNextImage, 200);
    }

    // Start the sequence
    showNextImage();
}


// Helper function to create an image from ImageData
function createImageFromData(imageData, width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    ctx.putImageData(new ImageData(imageData, width, height), 0, 0);
    return canvas.toDataURL();
}


    }
}
}

async function rightfootcode() {

const img = document.getElementById('sourceImage');
const mainContainer = document.getElementById('mainContainer');
mainContainer.innerHTML = '';

const imageGrid = document.createElement('div');
imageGrid.className = 'image-grid';

const segmentation = segmentationResult;
const bodyPartImages = {};
// collectedPoints.clear();

for (let partId = 0; partId < 24; partId++) {
    const partName = Object.keys(BODY_PARTS)[partId];
    if (!partName) continue;
    if (!segmentation.data.includes(partId)) {

        continue; 
    
    }

    const segmentCanvas = document.createElement('canvas');
    segmentCanvas.width = img.width;
    segmentCanvas.height = img.height;
    // const segmentCtx = segmentCanvas.getContext('2d');
    const segmentCtx = segmentCanvas.getContext('2d', { willReadFrequently: true });
    segmentCtx.drawImage(img, 0, 0);

    const imageData = segmentCtx.getImageData(0, 0, img.width, img.height);
  
    for (let i = 0; i < segmentation.data.length; i++) {
        if (segmentation.data[i] !== partId) imageData.data[i * 4 + 3] = 0;
    }

    const variations = await processSegmentVariations(imageData, partName);
    bodyPartImages[partName] = variations.map(v => ({
        imageData: v.data,
        width: img.width,
        height: img.height,
        extremePoints: v.extremePoints
    }));
}

const pointsToProcess = {
    leftFace: collectedPoints.get('left_face'),
    rightFace: collectedPoints.get('right_face'),
    leftUpperArmFront: collectedPoints.get('left_upper_arm_front'),
    leftUpperArmBack: collectedPoints.get('left_upper_arm_back'),
    leftLowerArmFront: collectedPoints.get('left_lower_arm_front'),
    leftLowerArmBack: collectedPoints.get('left_lower_arm_back'),
    leftHand: collectedPoints.get('left_hand'),
    rightUpperArmFront: collectedPoints.get('right_upper_arm_front'),
    rightUpperArmBack: collectedPoints.get('right_upper_arm_back'),
    rightLowerArmFront: collectedPoints.get('right_lower_arm_front'),
    rightLowerArmBack: collectedPoints.get('right_lower_arm_back'),
    rightHand: collectedPoints.get('right_hand'),
    torsoFront: collectedPoints.get('torso_front'),
    torsoBack: collectedPoints.get('torso_back'),
    leftUpperLegFront: collectedPoints.get('left_upper_leg_front'),
    leftUpperLegBack: collectedPoints.get('left_upper_leg_back'),
    leftLowerLegFront: collectedPoints.get('left_lower_leg_front'),
    leftLowerLegBack: collectedPoints.get('left_lower_leg_back'),
    rightUpperLegFront: collectedPoints.get('right_upper_leg_front'),
    rightUpperLegBack: collectedPoints.get('right_upper_leg_back'),
    rightLowerLegFront: collectedPoints.get('right_lower_leg_front'),
    rightLowerLegBack: collectedPoints.get('right_lower_leg_back'),
    leftFoot: collectedPoints.get('left_foot'),
    rightFoot: collectedPoints.get('right_foot')
};

segmentationWorker.postMessage({
    type: 'calculateAverage',
    points: pointsToProcess,
    bodyPartImages,
    partNames: {
        leftUpperArmFront: 'left_upper_arm_front',
        leftUpperArmBack: 'left_upper_arm_back',
        leftLowerArmFront: 'left_lower_arm_front',
        leftLowerArmBack: 'left_lower_arm_back',
        leftHand: 'left_hand',
        rightUpperArmFront: 'right_upper_arm_front',
        rightUpperArmBack: 'right_upper_arm_back',
        rightLowerArmFront: 'right_lower_arm_front',
        rightLowerArmBack: 'right_lower_arm_back',
        rightHand: 'right_hand',
        leftFoot: 'left_foot',
        rightFoot: 'right_foot',
        leftUpperFoot: 'left_upper_foot',
        leftLowerFoot: 'left_lower_foot',
        rightUpperFoot: 'right_upper_foot',
        rightLowerFoot: 'right_lower_foot',
        leftUpperLegFront: 'left_upper_leg_front',
        leftUpperLegBack: 'left_upper_leg_back',
        leftLowerLegFront: 'left_lower_leg_front',
        leftLowerLegBack: 'left_lower_leg_back',
        rightUpperLegFront: 'right_upper_leg_front',
        rightUpperLegBack: 'right_upper_leg_back',
        rightLowerLegFront: 'right_lower_leg_front',
        rightLowerLegBack: 'right_lower_leg_back'
    },
    offset: { x: 100, y: 50 },
    imageArray
}); 

segmentationWorker.onmessage = e => {
    const { type, averages, extremePoints, partNames } = e.data;
    // console.log(e.data);
    if (type === 'combinedResults' && (averages || extremePoints)) {
        
        processedData = {
            averages,   
            extremePoints,
            partNames,
            timestamp: Date.now()
        };

        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        // const ctx = canvas.getContext('2d');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.drawImage(img, 0, 0);

        const wrapper = document.createElement('div');
        wrapper.className = 'image-wrapper';
        wrapper.id = "wrapperid";
        wrapper.appendChild(canvas);
        canvas.id = "canvasid1";
        wrapper.appendChild(document.createElement('div')).className = 'keypoints-label';
        mainContainer.appendChild(wrapper);

        // Determine which workers to use based on extreme points
// Determine which workers to use based on extreme points

const legParts = [
    'leftFoot', 'rightFoot',
    'leftUpperLegFront', 'leftUpperLegBack', 
    'leftLowerLegFront', 'leftLowerLegBack',
    'rightUpperLegFront', 'rightUpperLegBack', 
    'rightLowerLegFront', 'rightLowerLegBack'
];

// Check if any leg parts are present
const hasLegParts = legParts.some(part => 
    extremePoints[part] && 
    Object.keys(extremePoints[part]).length > 0
);

// Create workers conditionally
const workersToUse = [];
if (hasLegParts) {
    // console.log("right foot ");
    const legWorker = new Worker('rightfootworker.js');
    workersToUse.push({
        worker: legWorker,
        type: 'leg'
    });
}

numberOfVariations = document.getElementById('imageCount').value;

const workerMessages = workersToUse.map(({type}) => ({
    type: e.data.type,
    imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),
    width: canvas.width,
    height: canvas.height,
    extremePoints,
    averages,
    timestamp: Date.now(),
    partNames,
    numberOfVariations, 
    bodyPartImages,
    rotationAngles: [0, 45, 90, 135, 180],
    imageArray
}));

let accumulatedVariations = [];

let totalVariationsExpected = numberOfVariations;

let totalworkerimages = 2 * numberOfVariations;

const generatedImages = [];
let combinedImagesProcessed = 0;

// Track already processed pairs
const processedPairs = new Set();

function attemptCombination() {
    for (let i = 0; i < totalworkerimages; i += 2) {
        // Stop if we already have the required number of combined images
        if (combinedImagesProcessed >= numberOfVariations) {
            break;
        }

        // Check if the pair has already been processed
        const pairKey = `${i}-${i + 1}`;
        if (generatedImages.length >= i + 2 && !processedPairs.has(pairKey)) {
            combineImagesByIndexes(i, i + 1); // Combine images in pairs
            processedPairs.add(pairKey); // Mark the pair as processed
            combinedImagesProcessed++;
        }
    }
}

const originalPush = generatedImages.push;
generatedImages.push = function (...args) {
    originalPush.apply(this, args);
    attemptCombination(); // Check if combinations can be processed
};

function safelyCombineImages(img1, img2) {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = img1.width;
        canvas.height = img1.height;

        ctx.drawImage(img1, 0, 0);

        ctx.globalAlpha = 1;

        const x = (canvas.width - img2.width) / 2;
        const y = (canvas.height - img2.height) / 2;
        ctx.drawImage(img2, x, y);

        ctx.globalAlpha = 1;

        const combinedImg = new Image();
        combinedImg.onload = () => resolve(combinedImg);
        combinedImg.onerror = reject;
        combinedImg.src = canvas.toDataURL();
    });
}

function combineImagesByIndexes(index1, index2) {
    const firstImageType = generatedImages[index1].type;
    const secondImageType = generatedImages[index2].type;

    // console.log(`Attempting to combine - First Type: ${firstImageType}, Second Type: ${secondImageType}`);

    // Prevent combination if types are the same
    if (firstImageType === secondImageType) {
        console.error(`Cannot combine images of the same type: ${firstImageType}`);
        return; // Exit the function immediately
    }

    if (generatedImages.length > Math.max(index1, index2)) {
        const imagePromises = [index1, index2].map(idx => {
            return new Promise((resolve, reject) => {
                const imgInfo = generatedImages[idx];
                const img = new Image();

                if (imgInfo.imageUrl) {
                    img.src = imgInfo.imageUrl;
                } else {
                    try {
                        img.src = createImageFromData(
                            imgInfo.imageData,
                            imgInfo.width,
                            imgInfo.height
                        );
                    } catch (error) {
                        console.error('Error creating image:', error);
                        reject(error);
                        return;
                    }
                }

                img.onload = () => resolve(img);
                img.onerror = reject;
            });
        });

        const imageContainer = document.getElementById('imageContainer');
imageContainer.innerHTML = ''; // Clear existing content
imageContainer.style.position = 'relative';
imageContainer.style.height = '600px'; // Adjust as needed
imageContainer.style.overflow = 'hidden';

// Add styles
const style = document.createElement('style');
style.textContent = `
    #imageContainer {
        position: relative;
        width: 100%;
        margin: 20px 0;
        overflow: hidden;
    }

    .image-wrapper {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
    }

    .image-wrapper.active {
        opacity: 1;
    }

    .image-wrapper img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }
`;
document.head.appendChild(style);

// Promise.allSettled code remains the same
Promise.allSettled(
    workersToUse.map(({ worker }, index) =>
        new Promise((resolve, reject) => {
            worker.onmessage = (e) => {
                if (e.data.type === 'processedVariations') {
                    if (!e.data.variations || e.data.variations.length === 0) {
                        console.warn(`No variations for ${workersToUse[index].type} worker`);
                        return;
                    }

                    workersToUse[index].variations = e.data.variations;

                    e.data.variations.forEach((variation, variationIndex) => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'image-wrapper';
                        
                        const img = document.createElement('img');
                        img.src = variation.imageUrl || createImageFromData(
                            variation.imageData,
                            variation.width,
                            variation.height
                        );

                        wrapper.appendChild(img);
                        imageContainer.appendChild(wrapper);

                        generatedImages.push({
                            index: variationIndex,
                            type: workersToUse[index].type,
                            wrapper: wrapper,
                            image: img
                        });
                    });

                    // Start animation when all workers are done
                    if (index === workersToUse.length - 1) {
                        startSequentialAnimation();
                    }

                    resolve({
                        type: workersToUse[index].type,
                        variations: e.data.variations
                    });
                }
            };

            worker.onerror = (error) => {
                console.error('Worker error:', error);
                reject(error);
            };

            worker.postMessage(workerMessages[index]);
        })
    )
).catch(error => {
    console.error('Overall worker processing error:', error);
});

// Modified sequential animation function for continuous animation
function startSequentialAnimation() {
    let currentIndex = 0;
    
    // First hide all images
    generatedImages.forEach(item => {
        item.wrapper.classList.remove('active');
    });

    function showNextImage() {
        // Hide current image
        if (currentIndex > 0) {
            generatedImages[currentIndex - 1].wrapper.classList.remove('active');
        } else {
            // When starting a new cycle, hide the last image
            generatedImages[generatedImages.length - 1].wrapper.classList.remove('active');
        }

        // Show next image
        generatedImages[currentIndex].wrapper.classList.add('active');

        // Increment counter
        currentIndex = (currentIndex + 1) % generatedImages.length;

        // Schedule next image - animation continues indefinitely
        setTimeout(showNextImage, 200);
    }

    // Start the sequence
    showNextImage();
}

        // Promise.all(imagePromises)
        //     .then(([img1, img2]) => safelyCombineImages(img1, img2))
        //     .then(combinedImg => {
        //         const combinedContainer = document.createElement('div');
        //         combinedContainer.className = 'combined-images-container';

        //         const combinedWrapper = document.createElement('div');
        //         combinedWrapper.className = 'image-wrapper combined';
        //         combinedWrapper.appendChild(combinedImg);

        //         const verificationInfo = document.createElement('div');
        //         verificationInfo.className = 'verification-info';
               
               

        //         combinedContainer.appendChild(verificationInfo);
        //         combinedContainer.appendChild(combinedWrapper);

        //         const container = document.getElementById('imageContainer');
        //         container.appendChild(combinedContainer);

        //         // console.log(`Images at indexes ${index1} and ${index2} combined successfully`);
        //     })
        //     .catch(error => {
        //         console.error(`Error combining images at indexes ${index1} and ${index2}:`, error);

        //         const errorContainer = document.createElement('div');
        //         errorContainer.className = 'verification-info';
        //         errorContainer.textContent = `Error combining images: ${error.message}`;

        //         const container = document.getElementById('imageContainer');
        //         container.appendChild(errorContainer);
        //     });
      
        }
}

// Worker processing
// Promise.allSettled(
//     workersToUse.map(({ worker }, index) =>
//         new Promise((resolve, reject) => {
//             worker.onmessage = (e) => {
//                 if (e.data.type === 'processedVariations') {
//                     if (!e.data.variations || e.data.variations.length === 0) {
//                         console.warn(`No variations for ${workersToUse[index].type} worker`);
//                         return;
//                     }

//                     workersToUse[index].variations = e.data.variations;

//                     e.data.variations.forEach((variation, variationIndex) => {
//                         const img = document.createElement('img');
//                         img.src = variation.imageUrl || createImageFromData(
//                             variation.imageData,
//                             variation.width,
//                             variation.height
//                         );

//                         const wrapper = document.createElement('div');
//                         wrapper.className = 'image-wrapper';

//                         wrapper.appendChild(img);

//                         const container = document.getElementById('imageContainer');
//                         container.appendChild(wrapper);
//                         // console.log(workersToUse[index].type);
//                         generatedImages.push({
//                             index: variationIndex,
//                             type: workersToUse[index].type,
//                             image: img,
//                             imageUrl: variation.imageUrl,
//                             imageData: variation.imageData,
//                             width: variation.width,
//                             height: variation.height
//                         });
//                         // // console.log('generatedImages :>> ', generatedImages);
                  
                  
//                     });

//                     resolve({
//                         type: workersToUse[index].type,
//                         variations: e.data.variations
//                     });
//                 }
//             };

//             worker.onerror = (error) => {
//                 console.error('Worker error:', error);
//                 reject(error);
//             };

//             worker.postMessage(workerMessages[index]);
//         })
//     )
// ).catch(error => {
//     console.error('Overall worker processing error:', error);
// });


const imageContainer = document.getElementById('imageContainer');
imageContainer.innerHTML = ''; // Clear existing content
imageContainer.style.position = 'relative';
imageContainer.style.height = '600px'; // Adjust as needed
imageContainer.style.overflow = 'hidden';

// Add styles
const style = document.createElement('style');
style.textContent = `
    #imageContainer {
        position: relative;
        width: 100%;
        margin: 20px 0;
        overflow: hidden;
    }

    .image-wrapper {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
    }

    .image-wrapper.active {
        opacity: 1;
    }

    .image-wrapper img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }
`;
document.head.appendChild(style);

// Promise.allSettled code remains the same
Promise.allSettled(
    workersToUse.map(({ worker }, index) =>
        new Promise((resolve, reject) => {
            worker.onmessage = (e) => {
                if (e.data.type === 'processedVariations') {
                    if (!e.data.variations || e.data.variations.length === 0) {
                        console.warn(`No variations for ${workersToUse[index].type} worker`);
                        return;
                    }

                    workersToUse[index].variations = e.data.variations;

                    e.data.variations.forEach((variation, variationIndex) => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'image-wrapper';
                        
                        const img = document.createElement('img');
                        img.src = variation.imageUrl || createImageFromData(
                            variation.imageData,
                            variation.width,
                            variation.height
                        );

                        wrapper.appendChild(img);
                        imageContainer.appendChild(wrapper);

                        generatedImages.push({
                            index: variationIndex,
                            type: workersToUse[index].type,
                            wrapper: wrapper,
                            image: img
                        });
                    });

                    // Start animation when all workers are done
                    if (index === workersToUse.length - 1) {
                        startSequentialAnimation();
                    }

                    resolve({
                        type: workersToUse[index].type,
                        variations: e.data.variations
                    });
                }
            };

            worker.onerror = (error) => {
                console.error('Worker error:', error);
                reject(error);
            };

            worker.postMessage(workerMessages[index]);
        })
    )
).catch(error => {
    console.error('Overall worker processing error:', error);
});

// Modified sequential animation function for continuous animation
function startSequentialAnimation() {
    let currentIndex = 0;
    
    // First hide all images
    generatedImages.forEach(item => {
        item.wrapper.classList.remove('active');
    });

    function showNextImage() {
        // Hide current image
        if (currentIndex > 0) {
            generatedImages[currentIndex - 1].wrapper.classList.remove('active');
        } else {
            // When starting a new cycle, hide the last image
            generatedImages[generatedImages.length - 1].wrapper.classList.remove('active');
        }

        // Show next image
        generatedImages[currentIndex].wrapper.classList.add('active');

        // Increment counter
        currentIndex = (currentIndex + 1) % generatedImages.length;

        // Schedule next image - animation continues indefinitely
        setTimeout(showNextImage, 200);
    }

    // Start the sequence
    showNextImage();
}
// Helper function to create an image from ImageData
function createImageFromData(imageData, width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    ctx.putImageData(new ImageData(imageData, width, height), 0, 0);
    return canvas.toDataURL();
}


    }
}
}

async function leftlegonly() {


const img = document.getElementById('sourceImage');
const mainContainer = document.getElementById('mainContainer');
mainContainer.innerHTML = '';

const imageGrid = document.createElement('div');
imageGrid.className = 'image-grid';

const segmentation = segmentationResult;
const bodyPartImages = {};
// collectedPoints.clear();

for (let partId = 0; partId < 24; partId++) {
    const partName = Object.keys(BODY_PARTS)[partId];
    if (!partName) continue;
    if (!segmentation.data.includes(partId)) {

        continue; 
    
    }

    const segmentCanvas = document.createElement('canvas');
    segmentCanvas.width = img.width;
    segmentCanvas.height = img.height;
    // const segmentCtx = segmentCanvas.getContext('2d');
    const segmentCtx = segmentCanvas.getContext('2d', { willReadFrequently: true });
    segmentCtx.drawImage(img, 0, 0);

    const imageData = segmentCtx.getImageData(0, 0, img.width, img.height);
  
    for (let i = 0; i < segmentation.data.length; i++) {
        if (segmentation.data[i] !== partId) imageData.data[i * 4 + 3] = 0;
    }

    const variations = await processSegmentVariations(imageData, partName);
    bodyPartImages[partName] = variations.map(v => ({
        imageData: v.data,
        width: img.width,
        height: img.height,
        extremePoints: v.extremePoints
    }));
}

const pointsToProcess = {
    leftFace: collectedPoints.get('left_face'),
    rightFace: collectedPoints.get('right_face'),
    leftUpperArmFront: collectedPoints.get('left_upper_arm_front'),
    leftUpperArmBack: collectedPoints.get('left_upper_arm_back'),
    leftLowerArmFront: collectedPoints.get('left_lower_arm_front'),
    leftLowerArmBack: collectedPoints.get('left_lower_arm_back'),
    leftHand: collectedPoints.get('left_hand'),
    rightUpperArmFront: collectedPoints.get('right_upper_arm_front'),
    rightUpperArmBack: collectedPoints.get('right_upper_arm_back'),
    rightLowerArmFront: collectedPoints.get('right_lower_arm_front'),
    rightLowerArmBack: collectedPoints.get('right_lower_arm_back'),
    rightHand: collectedPoints.get('right_hand'),
    torsoFront: collectedPoints.get('torso_front'),
    torsoBack: collectedPoints.get('torso_back'),
    leftUpperLegFront: collectedPoints.get('left_upper_leg_front'),
    leftUpperLegBack: collectedPoints.get('left_upper_leg_back'),
    leftLowerLegFront: collectedPoints.get('left_lower_leg_front'),
    leftLowerLegBack: collectedPoints.get('left_lower_leg_back'),
    rightUpperLegFront: collectedPoints.get('right_upper_leg_front'),
    rightUpperLegBack: collectedPoints.get('right_upper_leg_back'),
    rightLowerLegFront: collectedPoints.get('right_lower_leg_front'),
    rightLowerLegBack: collectedPoints.get('right_lower_leg_back'),
    leftFoot: collectedPoints.get('left_foot'),
    rightFoot: collectedPoints.get('right_foot')
};

segmentationWorker.postMessage({
    type: 'calculateAverage',
    points: pointsToProcess,
    bodyPartImages,
    partNames: {
        leftUpperArmFront: 'left_upper_arm_front',
        leftUpperArmBack: 'left_upper_arm_back',
        leftLowerArmFront: 'left_lower_arm_front',
        leftLowerArmBack: 'left_lower_arm_back',
        leftHand: 'left_hand',
        rightUpperArmFront: 'right_upper_arm_front',
        rightUpperArmBack: 'right_upper_arm_back',
        rightLowerArmFront: 'right_lower_arm_front',
        rightLowerArmBack: 'right_lower_arm_back',
        rightHand: 'right_hand',
        leftFoot: 'left_foot',
        rightFoot: 'right_foot',
        leftUpperFoot: 'left_upper_foot',
        leftLowerFoot: 'left_lower_foot',
        rightUpperFoot: 'right_upper_foot',
        rightLowerFoot: 'right_lower_foot',
        leftUpperLegFront: 'left_upper_leg_front',
        leftUpperLegBack: 'left_upper_leg_back',
        leftLowerLegFront: 'left_lower_leg_front',
        leftLowerLegBack: 'left_lower_leg_back',
        rightUpperLegFront: 'right_upper_leg_front',
        rightUpperLegBack: 'right_upper_leg_back',
        rightLowerLegFront: 'right_lower_leg_front',
        rightLowerLegBack: 'right_lower_leg_back'
    },
    offset: { x: 100, y: 50 },
    imageArray
}); 

segmentationWorker.onmessage = e => {
    const { type, averages, extremePoints, partNames } = e.data;
    // console.log(e.data);
    if (type === 'combinedResults' && (averages || extremePoints)) {
        
        processedData = {
            averages,
            extremePoints,
            partNames,
            timestamp: Date.now()
        };

        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        // const ctx = canvas.getContext('2d');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.drawImage(img, 0, 0);

        const wrapper = document.createElement('div');
        wrapper.className = 'image-wrapper';
        wrapper.id = "wrapperid";
        wrapper.appendChild(canvas);
        canvas.id = "canvasid1";
        wrapper.appendChild(document.createElement('div')).className = 'keypoints-label';
        mainContainer.appendChild(wrapper);

        // Determine which workers to use based on extreme points

// Determine which workers to use based on extreme points
const legParts = [
    'leftFoot', 'rightFoot',
    'leftUpperLegFront', 'leftUpperLegBack', 
    'leftLowerLegFront', 'leftLowerLegBack',
    'rightUpperLegFront', 'rightUpperLegBack', 
    'rightLowerLegFront', 'rightLowerLegBack'
];

// Check if any leg parts are present
const hasLegParts = legParts.some(part => 
    extremePoints[part] && 
    Object.keys(extremePoints[part]).length > 0
);

// Create workers conditionally
const workersToUse = [];
if (hasLegParts) {
    const legWorker = new Worker('leftlegonlyworker.js');
    workersToUse.push({
        worker: legWorker,
        type: 'leg'
    });
}

numberOfVariations = document.getElementById('imageCount').value;

const workerMessages = workersToUse.map(({type}) => ({
    type: e.data.type,
    imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),
    width: canvas.width,
    height: canvas.height,
    extremePoints,
    averages,
    timestamp: Date.now(),
    partNames,
    numberOfVariations, 
    bodyPartImages,
    rotationAngles: [0, 45, 90, 135, 180],
    imageArray
}));

let accumulatedVariations = [];

let totalVariationsExpected = numberOfVariations;

let totalworkerimages = 2 * numberOfVariations;

const generatedImages = [];
let combinedImagesProcessed = 0;

// Track already processed pairs
const processedPairs = new Set();

function attemptCombination() {
    for (let i = 0; i < totalworkerimages; i += 2) {
        // Stop if we already have the required number of combined images
        if (combinedImagesProcessed >= numberOfVariations) {
            break;
        }

        // Check if the pair has already been processed
        const pairKey = `${i}-${i + 1}`;
        if (generatedImages.length >= i + 2 && !processedPairs.has(pairKey)) {
            combineImagesByIndexes(i, i + 1); // Combine images in pairs
            processedPairs.add(pairKey); // Mark the pair as processed
            combinedImagesProcessed++;
        }
    }
}

// Overwrite the `push` method of the generatedImages array to trigger combination checks dynamically
const originalPush = generatedImages.push;
generatedImages.push = function (...args) {
    originalPush.apply(this, args);
    attemptCombination(); // Check if combinations can be processed
};

function safelyCombineImages(img1, img2) {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = img1.width;
        canvas.height = img1.height;

        ctx.drawImage(img1, 0, 0);

        ctx.globalAlpha = 1;

        const x = (canvas.width - img2.width) / 2;
        const y = (canvas.height - img2.height) / 2;
        ctx.drawImage(img2, x, y);

        ctx.globalAlpha = 1;

        const combinedImg = new Image();
        combinedImg.onload = () => resolve(combinedImg);
        combinedImg.onerror = reject;
        combinedImg.src = canvas.toDataURL();
    });
}

function combineImagesByIndexes(index1, index2) {
    const firstImageType = generatedImages[index1].type;
    const secondImageType = generatedImages[index2].type;

    // console.log(`Attempting to combine - First Type: ${firstImageType}, Second Type: ${secondImageType}`);

    // Prevent combination if types are the same
    if (firstImageType === secondImageType) {
        console.error(`Cannot combine images of the same type: ${firstImageType}`);
        return; // Exit the function immediately
    }

    if (generatedImages.length > Math.max(index1, index2)) {
        const imagePromises = [index1, index2].map(idx => {
            return new Promise((resolve, reject) => {
                const imgInfo = generatedImages[idx];
                const img = new Image();

                if (imgInfo.imageUrl) {
                    img.src = imgInfo.imageUrl;
                } else {
                    try {
                        img.src = createImageFromData(
                            imgInfo.imageData,
                            imgInfo.width,
                            imgInfo.height
                        );
                    } catch (error) {
                        console.error('Error creating image:', error);
                        reject(error);
                        return;
                    }
                }

                img.onload = () => resolve(img);
                img.onerror = reject;
            });
        });

        // Promise.all(imagePromises)
        //     .then(([img1, img2]) => safelyCombineImages(img1, img2))
        //     .then(combinedImg => {
        //         const combinedContainer = document.createElement('div');
        //         combinedContainer.className = 'combined-images-container';

        //         const combinedWrapper = document.createElement('div');
        //         combinedWrapper.className = 'image-wrapper combined';
        //         combinedWrapper.appendChild(combinedImg);

        //         const verificationInfo = document.createElement('div');
        //         verificationInfo.className = 'verification-info';
        //         verificationInfo.innerHTML = `
        //             Combination Verification:
        //             <br>First Image Type: ${generatedImages[index1].type}
        //             <br>Second Image Type: ${generatedImages[index2].type}
        //             <br>First Image Dimensions: ${generatedImages[index1].width}x${generatedImages[index1].height}
        //             <br>Second Image Dimensions: ${generatedImages[index2].width}x${generatedImages[index2].height}
        //             <br>Combined Image Dimensions: ${combinedImg.width}x${combinedImg.height}
        //         `;

        //         combinedContainer.appendChild(verificationInfo);
        //         combinedContainer.appendChild(combinedWrapper);

        //         const container = document.getElementById('imageContainer');
        //         container.appendChild(combinedContainer);

        //         // console.log(`Images at indexes ${index1} and ${index2} combined successfully`);
        //     })
        //     .catch(error => {
        //         console.error(`Error combining images at indexes ${index1} and ${index2}:`, error);

        //         const errorContainer = document.createElement('div');
        //         errorContainer.className = 'verification-info';
        //         errorContainer.textContent = `Error combining images: ${error.message}`;

        //         const container = document.getElementById('imageContainer');
        //         container.appendChild(errorContainer);
        //     });
      
        }
}

// // Worker processing
// Promise.allSettled(
//     workersToUse.map(({ worker }, index) =>
//         new Promise((resolve, reject) => {
//             worker.onmessage = (e) => {
//                 if (e.data.type === 'processedVariations') {
//                     if (!e.data.variations || e.data.variations.length === 0) {
//                         console.warn(`No variations for ${workersToUse[index].type} worker`);
//                         return;
//                     }

//                     workersToUse[index].variations = e.data.variations;

//                     e.data.variations.forEach((variation, variationIndex) => {
//                         const img = document.createElement('img');
//                         img.src = variation.imageUrl || createImageFromData(
//                             variation.imageData,
//                             variation.width,
//                             variation.height
//                         );

//                         const wrapper = document.createElement('div');
//                         wrapper.className = 'image-wrapper';

//                         wrapper.appendChild(img);

//                         const container = document.getElementById('imageContainer');
//                         container.appendChild(wrapper);
//                         // console.log(workersToUse[index].type);
//                         generatedImages.push({
//                             index: variationIndex,
//                             type: workersToUse[index].type,
//                             image: img,
//                             imageUrl: variation.imageUrl,
//                             imageData: variation.imageData,
//                             width: variation.width,
//                             height: variation.height
//                         });
//                         // console.log('generatedImages :>> ', generatedImages);
//                     });

//                     resolve({
//                         type: workersToUse[index].type,
//                         variations: e.data.variations
//                     });
//                 }
//             };

//             worker.onerror = (error) => {
//                 console.error('Worker error:', error);
//                 reject(error);
//             };

//             worker.postMessage(workerMessages[index]);
//         })
//     )
// ).catch(error => {
//     console.error('Overall worker processing error:', error);
// });



const imageContainer = document.getElementById('imageContainer');
imageContainer.innerHTML = ''; // Clear existing content
imageContainer.style.position = 'relative';
imageContainer.style.height = '600px'; // Adjust as needed
imageContainer.style.overflow = 'hidden';

// Add styles
const style = document.createElement('style');
style.textContent = `
    #imageContainer {
        position: relative;
        width: 100%;
        margin: 20px 0;
        overflow: hidden;
    }

    .image-wrapper {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
    }

    .image-wrapper.active {
        opacity: 1;
    }

    .image-wrapper img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }
`;
document.head.appendChild(style);

// Promise.allSettled code remains the same
Promise.allSettled(
    workersToUse.map(({ worker }, index) =>
        new Promise((resolve, reject) => {
            worker.onmessage = (e) => {
                if (e.data.type === 'processedVariations') {
                    if (!e.data.variations || e.data.variations.length === 0) {
                        console.warn(`No variations for ${workersToUse[index].type} worker`);
                        return;
                    }

                    workersToUse[index].variations = e.data.variations;

                    e.data.variations.forEach((variation, variationIndex) => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'image-wrapper';
                        
                        const img = document.createElement('img');
                        img.src = variation.imageUrl || createImageFromData(
                            variation.imageData,
                            variation.width,
                            variation.height
                        );

                        wrapper.appendChild(img);
                        imageContainer.appendChild(wrapper);

                        generatedImages.push({
                            index: variationIndex,
                            type: workersToUse[index].type,
                            wrapper: wrapper,
                            image: img
                        });
                    });

                    // Start animation when all workers are done
                    if (index === workersToUse.length - 1) {
                        startSequentialAnimation();
                    }

                    resolve({
                        type: workersToUse[index].type,
                        variations: e.data.variations
                    });
                }
            };

            worker.onerror = (error) => {
                console.error('Worker error:', error);
                reject(error);
            };

            worker.postMessage(workerMessages[index]);
        })
    )
).catch(error => {
    console.error('Overall worker processing error:', error);
});

// Modified sequential animation function for continuous animation
function startSequentialAnimation() {
    let currentIndex = 0;
    
    // First hide all images
    generatedImages.forEach(item => {
        item.wrapper.classList.remove('active');
    });

    function showNextImage() {
        // Hide current image
        if (currentIndex > 0) {
            generatedImages[currentIndex - 1].wrapper.classList.remove('active');
        } else {
            // When starting a new cycle, hide the last image
            generatedImages[generatedImages.length - 1].wrapper.classList.remove('active');
        }

        // Show next image
        generatedImages[currentIndex].wrapper.classList.add('active');

        // Increment counter
        currentIndex = (currentIndex + 1) % generatedImages.length;

        // Schedule next image - animation continues indefinitely
        setTimeout(showNextImage, 200);
    }

    // Start the sequence
    showNextImage();
}
// Helper function to create an image from ImageData
function createImageFromData(imageData, width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    ctx.putImageData(new ImageData(imageData, width, height), 0, 0);
    return canvas.toDataURL();
}


    }
}
}

async function rightlegonly() {

// console.log("1111111111111111");
const img = document.getElementById('sourceImage');
const mainContainer = document.getElementById('mainContainer');
mainContainer.innerHTML = '';

const imageGrid = document.createElement('div');
imageGrid.className = 'image-grid';

const segmentation = segmentationResult;
const bodyPartImages = {};
// collectedPoints.clear();

for (let partId = 0; partId < 24; partId++) {
    const partName = Object.keys(BODY_PARTS)[partId];
    if (!partName) continue;
    if (!segmentation.data.includes(partId)) {

        continue; 
    
    }

    const segmentCanvas = document.createElement('canvas');
    segmentCanvas.width = img.width;
    segmentCanvas.height = img.height;
    // const segmentCtx = segmentCanvas.getContext('2d');
    const segmentCtx = segmentCanvas.getContext('2d', { willReadFrequently: true });
    segmentCtx.drawImage(img, 0, 0);

    const imageData = segmentCtx.getImageData(0, 0, img.width, img.height);
  
    for (let i = 0; i < segmentation.data.length; i++) {
        if (segmentation.data[i] !== partId) imageData.data[i * 4 + 3] = 0;
    }

    const variations = await processSegmentVariations(imageData, partName);
    bodyPartImages[partName] = variations.map(v => ({
        imageData: v.data,
        width: img.width,
        height: img.height,
        extremePoints: v.extremePoints
    }));
}

const pointsToProcess = {
    leftFace: collectedPoints.get('left_face'),
    rightFace: collectedPoints.get('right_face'),
    leftUpperArmFront: collectedPoints.get('left_upper_arm_front'),
    leftUpperArmBack: collectedPoints.get('left_upper_arm_back'),
    leftLowerArmFront: collectedPoints.get('left_lower_arm_front'),
    leftLowerArmBack: collectedPoints.get('left_lower_arm_back'),
    leftHand: collectedPoints.get('left_hand'),
    rightUpperArmFront: collectedPoints.get('right_upper_arm_front'),
    rightUpperArmBack: collectedPoints.get('right_upper_arm_back'),
    rightLowerArmFront: collectedPoints.get('right_lower_arm_front'),
    rightLowerArmBack: collectedPoints.get('right_lower_arm_back'),
    rightHand: collectedPoints.get('right_hand'),
    torsoFront: collectedPoints.get('torso_front'),
    torsoBack: collectedPoints.get('torso_back'),
    leftUpperLegFront: collectedPoints.get('left_upper_leg_front'),
    leftUpperLegBack: collectedPoints.get('left_upper_leg_back'),
    leftLowerLegFront: collectedPoints.get('left_lower_leg_front'),
    leftLowerLegBack: collectedPoints.get('left_lower_leg_back'),
    rightUpperLegFront: collectedPoints.get('right_upper_leg_front'),
    rightUpperLegBack: collectedPoints.get('right_upper_leg_back'),
    rightLowerLegFront: collectedPoints.get('right_lower_leg_front'),
    rightLowerLegBack: collectedPoints.get('right_lower_leg_back'),
    leftFoot: collectedPoints.get('left_foot'),
    rightFoot: collectedPoints.get('right_foot')
};

segmentationWorker.postMessage({
    type: 'calculateAverage',
    points: pointsToProcess,
    bodyPartImages,
    partNames: {
        leftUpperArmFront: 'left_upper_arm_front',
        leftUpperArmBack: 'left_upper_arm_back',
        leftLowerArmFront: 'left_lower_arm_front',
        leftLowerArmBack: 'left_lower_arm_back',
        leftHand: 'left_hand',
        rightUpperArmFront: 'right_upper_arm_front',
        rightUpperArmBack: 'right_upper_arm_back',
        rightLowerArmFront: 'right_lower_arm_front',
        rightLowerArmBack: 'right_lower_arm_back',
        rightHand: 'right_hand',
        leftFoot: 'left_foot',
        rightFoot: 'right_foot',
        leftUpperFoot: 'left_upper_foot',
        leftLowerFoot: 'left_lower_foot',
        rightUpperFoot: 'right_upper_foot',
        rightLowerFoot: 'right_lower_foot',
        leftUpperLegFront: 'left_upper_leg_front',
        leftUpperLegBack: 'left_upper_leg_back',
        leftLowerLegFront: 'left_lower_leg_front',
        leftLowerLegBack: 'left_lower_leg_back',
        rightUpperLegFront: 'right_upper_leg_front',
        rightUpperLegBack: 'right_upper_leg_back',
        rightLowerLegFront: 'right_lower_leg_front',
        rightLowerLegBack: 'right_lower_leg_back'
    },
    offset: { x: 100, y: 50 },
    imageArray
}); 

segmentationWorker.onmessage = e => {
    const { type, averages, extremePoints, partNames } = e.data;
    // console.log(e.data);
    if (type === 'combinedResults' && (averages || extremePoints)) {
        
        processedData = {
            averages,
            extremePoints,
            partNames,
            timestamp: Date.now()
        };

        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        // const ctx = canvas.getContext('2d');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.drawImage(img, 0, 0);

        const wrapper = document.createElement('div');
        wrapper.className = 'image-wrapper';
        wrapper.id = "wrapperid";
        wrapper.appendChild(canvas);
        canvas.id = "canvasid1";
        wrapper.appendChild(document.createElement('div')).className = 'keypoints-label';
        mainContainer.appendChild(wrapper);

        // Determine which workers to use based on extreme points

// Determine which workers to use based on extreme points
const legParts = [
    'leftFoot', 'rightFoot',
    'leftUpperLegFront', 'leftUpperLegBack', 
    'leftLowerLegFront', 'leftLowerLegBack',
    'rightUpperLegFront', 'rightUpperLegBack', 
    'rightLowerLegFront', 'rightLowerLegBack'
];

// Check if any leg parts are present
const hasLegParts = legParts.some(part => 
    extremePoints[part] && 
    Object.keys(extremePoints[part]).length > 0
);

// Create workers conditionally
const workersToUse = [];
if (hasLegParts) {
    const legWorker = new Worker('rightlegonlyworker.js');
    workersToUse.push({
        worker: legWorker,
        type: 'leg'
    });
}

numberOfVariations = document.getElementById('imageCount').value;

const workerMessages = workersToUse.map(({type}) => ({
    type: e.data.type,
    imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),
    width: canvas.width,
    height: canvas.height,
    extremePoints,
    averages,
    timestamp: Date.now(),
    partNames,
    numberOfVariations, 
    bodyPartImages,
    rotationAngles: [0, 45, 90, 135, 180],
    imageArray
}));

let accumulatedVariations = [];

let totalVariationsExpected = numberOfVariations;

let totalworkerimages = 2 * numberOfVariations;

const generatedImages = [];
let combinedImagesProcessed = 0;

// Track already processed pairs
const processedPairs = new Set();

function attemptCombination() {
    for (let i = 0; i < totalworkerimages; i += 2) {
        // Stop if we already have the required number of combined images
        if (combinedImagesProcessed >= numberOfVariations) {
            break;
        }

        // Check if the pair has already been processed
        const pairKey = `${i}-${i + 1}`;
        if (generatedImages.length >= i + 2 && !processedPairs.has(pairKey)) {
            combineImagesByIndexes(i, i + 1); // Combine images in pairs
            processedPairs.add(pairKey); // Mark the pair as processed
            combinedImagesProcessed++;
        }
    }
}

// Overwrite the `push` method of the generatedImages array to trigger combination checks dynamically
const originalPush = generatedImages.push;
generatedImages.push = function (...args) {
    originalPush.apply(this, args);
    attemptCombination(); // Check if combinations can be processed
};

function safelyCombineImages(img1, img2) {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = img1.width;
        canvas.height = img1.height;

        ctx.drawImage(img1, 0, 0);

        ctx.globalAlpha = 1;

        const x = (canvas.width - img2.width) / 2;
        const y = (canvas.height - img2.height) / 2;
        ctx.drawImage(img2, x, y);

        ctx.globalAlpha = 1;

        const combinedImg = new Image();
        combinedImg.onload = () => resolve(combinedImg);
        combinedImg.onerror = reject;
        combinedImg.src = canvas.toDataURL();
    });
}

function combineImagesByIndexes(index1, index2) {
    const firstImageType = generatedImages[index1].type;
    const secondImageType = generatedImages[index2].type;

    // console.log(`Attempting to combine - First Type: ${firstImageType}, Second Type: ${secondImageType}`);

    // Prevent combination if types are the same
    if (firstImageType === secondImageType) {
        console.error(`Cannot combine images of the same type: ${firstImageType}`);
        return; // Exit the function immediately
    }

    if (generatedImages.length > Math.max(index1, index2)) {
        const imagePromises = [index1, index2].map(idx => {
            return new Promise((resolve, reject) => {
                const imgInfo = generatedImages[idx];
                const img = new Image();

                if (imgInfo.imageUrl) {
                    img.src = imgInfo.imageUrl;
                } else {
                    try {
                        img.src = createImageFromData(
                            imgInfo.imageData,
                            imgInfo.width,
                            imgInfo.height
                        );
                    } catch (error) {
                        console.error('Error creating image:', error);
                        reject(error);
                        return;
                    }
                }

                img.onload = () => resolve(img);
                img.onerror = reject;
            });
        });

        // Promise.all(imagePromises)
        //     .then(([img1, img2]) => safelyCombineImages(img1, img2))
        //     .then(combinedImg => {
        //         const combinedContainer = document.createElement('div');
        //         combinedContainer.className = 'combined-images-container';

        //         const combinedWrapper = document.createElement('div');
        //         combinedWrapper.className = 'image-wrapper combined';
        //         combinedWrapper.appendChild(combinedImg);

        //         const verificationInfo = document.createElement('div');
        //         verificationInfo.className = 'verification-info';
        //         verificationInfo.innerHTML = `
        //             Combination Verification:
        //             <br>First Image Type: ${generatedImages[index1].type}
        //             <br>Second Image Type: ${generatedImages[index2].type}
        //             <br>First Image Dimensions: ${generatedImages[index1].width}x${generatedImages[index1].height}
        //             <br>Second Image Dimensions: ${generatedImages[index2].width}x${generatedImages[index2].height}
        //             <br>Combined Image Dimensions: ${combinedImg.width}x${combinedImg.height}
        //         `;

        //         combinedContainer.appendChild(verificationInfo);
        //         combinedContainer.appendChild(combinedWrapper);

        //         const container = document.getElementById('imageContainer');
        //         container.appendChild(combinedContainer);

        //         // console.log(`Images at indexes ${index1} and ${index2} combined successfully`);
        //     })
        //     .catch(error => {
        //         console.error(`Error combining images at indexes ${index1} and ${index2}:`, error);

        //         const errorContainer = document.createElement('div');
        //         errorContainer.className = 'verification-info';
        //         errorContainer.textContent = `Error combining images: ${error.message}`;

        //         const container = document.getElementById('imageContainer');
        //         container.appendChild(errorContainer);
        //     });
      
        }
}

// // Worker processing
// Promise.allSettled(
//     workersToUse.map(({ worker }, index) =>
//         new Promise((resolve, reject) => {
//             worker.onmessage = (e) => {
//                 if (e.data.type === 'processedVariations') {
//                     if (!e.data.variations || e.data.variations.length === 0) {
//                         console.warn(`No variations for ${workersToUse[index].type} worker`);
//                         return;
//                     }

//                     workersToUse[index].variations = e.data.variations;

//                     e.data.variations.forEach((variation, variationIndex) => {
//                         const img = document.createElement('img');
//                         img.src = variation.imageUrl || createImageFromData(
//                             variation.imageData,
//                             variation.width,
//                             variation.height
//                         );

//                         const wrapper = document.createElement('div');
//                         wrapper.className = 'image-wrapper';

//                         wrapper.appendChild(img);

//                         const container = document.getElementById('imageContainer');
//                         container.appendChild(wrapper);
//                         // console.log(workersToUse[index].type);
//                         generatedImages.push({
//                             index: variationIndex,
//                             type: workersToUse[index].type,
//                             image: img,
//                             imageUrl: variation.imageUrl,
//                             imageData: variation.imageData,
//                             width: variation.width,
//                             height: variation.height
//                         });
//                         // console.log('generatedImages :>> ', generatedImages);
//                     });

//                     resolve({
//                         type: workersToUse[index].type,
//                         variations: e.data.variations
//                     });
//                 }
//             };

//             worker.onerror = (error) => {
//                 console.error('Worker error:', error);
//                 reject(error);
//             };

//             worker.postMessage(workerMessages[index]);
//         })
//     )
// ).catch(error => {
//     console.error('Overall worker processing error:', error);
// });


const imageContainer = document.getElementById('imageContainer');
imageContainer.innerHTML = ''; // Clear existing content
imageContainer.style.position = 'relative';
imageContainer.style.height = '600px'; // Adjust as needed
imageContainer.style.overflow = 'hidden';

// Add styles
const style = document.createElement('style');
style.textContent = `
    #imageContainer {
        position: relative;
        width: 100%;
        margin: 20px 0;
        overflow: hidden;
    }

    .image-wrapper {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
                }

    .image-wrapper.active {
        opacity: 1;
    }

    .image-wrapper img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }
`;
document.head.appendChild(style);

// Promise.allSettled code remains the same
Promise.allSettled(
    workersToUse.map(({ worker }, index) =>
        new Promise((resolve, reject) => {
            worker.onmessage = (e) => {
                if (e.data.type === 'processedVariations') {
                    if (!e.data.variations || e.data.variations.length === 0) {
                        console.warn(`No variations for ${workersToUse[index].type} worker`);
                        return;
                    }

                    workersToUse[index].variations = e.data.variations;

                    e.data.variations.forEach((variation, variationIndex) => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'image-wrapper';
                        
                        const img = document.createElement('img');
                        img.src = variation.imageUrl || createImageFromData(
                            variation.imageData,
                            variation.width,
                            variation.height
                        );

                        wrapper.appendChild(img);
                        imageContainer.appendChild(wrapper);

                        generatedImages.push({
                            index: variationIndex,
                            type: workersToUse[index].type,
                            wrapper: wrapper,
                            image: img
                        });

                    });

                    // Start animation when all workers are done
                    if (index === workersToUse.length - 1) {
                        startSequentialAnimation();
                    }

                    resolve({
                        type: workersToUse[index].type,
                        variations: e.data.variations
                    });
                }
            };

            worker.onerror = (error) => {
                console.error('Worker error:', error);
                reject(error);
            };

            worker.postMessage(workerMessages[index]);
        })
    )
).catch(error => {
    console.error('Overall worker processing error:', error);
});

// Modified sequential animation function for continuous animation
function startSequentialAnimation() {
    let currentIndex = 0;
    
    // First hide all images
    generatedImages.forEach(item => {
        item.wrapper.classList.remove('active');
    });

    function showNextImage() {
        // Hide current image
        if (currentIndex > 0) {
            generatedImages[currentIndex - 1].wrapper.classList.remove('active');
        } else {
            // When starting a new cycle, hide the last image
            generatedImages[generatedImages.length - 1].wrapper.classList.remove('active');
        }

        // Show next image
        generatedImages[currentIndex].wrapper.classList.add('active');

        // Increment counter
        currentIndex = (currentIndex + 1) % generatedImages.length;

        // Schedule next image - animation continues indefinitely
        setTimeout(showNextImage, 200);
    }

    // Start the sequence
    showNextImage();
}

// Helper function to create an image from ImageData
function createImageFromData(imageData, width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    ctx.putImageData(new ImageData(imageData, width, height), 0, 0);
    return canvas.toDataURL();
}


    }
}
}

async function rightarmonly() {

// console.log("1111111111111111");
const img = document.getElementById('sourceImage');
const mainContainer = document.getElementById('mainContainer');
mainContainer.innerHTML = '';

const imageGrid = document.createElement('div');
imageGrid.className = 'image-grid';

const segmentation = segmentationResult;
const bodyPartImages = {};
// collectedPoints.clear();

for (let partId = 0; partId < 24; partId++) {
    const partName = Object.keys(BODY_PARTS)[partId];
    if (!partName) continue;
    if (!segmentation.data.includes(partId)) {

        continue; 
    
    }

    const segmentCanvas = document.createElement('canvas');
    segmentCanvas.width = img.width;
    segmentCanvas.height = img.height;
    // const segmentCtx = segmentCanvas.getContext('2d');
    const segmentCtx = segmentCanvas.getContext('2d', { willReadFrequently: true });
    segmentCtx.drawImage(img, 0, 0);

    const imageData = segmentCtx.getImageData(0, 0, img.width, img.height);
  
    for (let i = 0; i < segmentation.data.length; i++) {
        if (segmentation.data[i] !== partId) imageData.data[i * 4 + 3] = 0;
    }

    const variations = await processSegmentVariations(imageData, partName);
    bodyPartImages[partName] = variations.map(v => ({
        imageData: v.data,
        width: img.width,
        height: img.height,
        extremePoints: v.extremePoints
    }));
}

const pointsToProcess = {
    leftFace: collectedPoints.get('left_face'),
    rightFace: collectedPoints.get('right_face'),
    leftUpperArmFront: collectedPoints.get('left_upper_arm_front'),
    leftUpperArmBack: collectedPoints.get('left_upper_arm_back'),
    leftLowerArmFront: collectedPoints.get('left_lower_arm_front'),
    leftLowerArmBack: collectedPoints.get('left_lower_arm_back'),
    leftHand: collectedPoints.get('left_hand'),
    rightUpperArmFront: collectedPoints.get('right_upper_arm_front'),
    rightUpperArmBack: collectedPoints.get('right_upper_arm_back'),
    rightLowerArmFront: collectedPoints.get('right_lower_arm_front'),
    rightLowerArmBack: collectedPoints.get('right_lower_arm_back'),
    rightHand: collectedPoints.get('right_hand'),
    torsoFront: collectedPoints.get('torso_front'),
    torsoBack: collectedPoints.get('torso_back'),
    leftUpperLegFront: collectedPoints.get('left_upper_leg_front'),
    leftUpperLegBack: collectedPoints.get('left_upper_leg_back'),
    leftLowerLegFront: collectedPoints.get('left_lower_leg_front'),
    leftLowerLegBack: collectedPoints.get('left_lower_leg_back'),
    rightUpperLegFront: collectedPoints.get('right_upper_leg_front'),
    rightUpperLegBack: collectedPoints.get('right_upper_leg_back'),
    rightLowerLegFront: collectedPoints.get('right_lower_leg_front'),
    rightLowerLegBack: collectedPoints.get('right_lower_leg_back'),
    leftFoot: collectedPoints.get('left_foot'),
    rightFoot: collectedPoints.get('right_foot')
};

segmentationWorker.postMessage({
    type: 'calculateAverage',
    points: pointsToProcess,
    bodyPartImages,
    partNames: {
        leftUpperArmFront: 'left_upper_arm_front',
        leftUpperArmBack: 'left_upper_arm_back',
        leftLowerArmFront: 'left_lower_arm_front',
        leftLowerArmBack: 'left_lower_arm_back',
        leftHand: 'left_hand',
        rightUpperArmFront: 'right_upper_arm_front',
        rightUpperArmBack: 'right_upper_arm_back',
        rightLowerArmFront: 'right_lower_arm_front',
        rightLowerArmBack: 'right_lower_arm_back',
        rightHand: 'right_hand',
        leftFoot: 'left_foot',
        rightFoot: 'right_foot',
        leftUpperFoot: 'left_upper_foot',
        leftLowerFoot: 'left_lower_foot',
        rightUpperFoot: 'right_upper_foot',
        rightLowerFoot: 'right_lower_foot',
        leftUpperLegFront: 'left_upper_leg_front',
        leftUpperLegBack: 'left_upper_leg_back',
        leftLowerLegFront: 'left_lower_leg_front',
        leftLowerLegBack: 'left_lower_leg_back',
        rightUpperLegFront: 'right_upper_leg_front',
        rightUpperLegBack: 'right_upper_leg_back',
        rightLowerLegFront: 'right_lower_leg_front',
        rightLowerLegBack: 'right_lower_leg_back'
    },
    offset: { x: 100, y: 50 },
    imageArray
}); 

segmentationWorker.onmessage = e => {
    const { type, averages, extremePoints, partNames } = e.data;
    // console.log(e.data);
    if (type === 'combinedResults' && (averages || extremePoints)) {
        
        processedData = {
            averages,
            extremePoints,
            partNames,
            timestamp: Date.now()
        };

        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        // const ctx = canvas.getContext('2d');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.drawImage(img, 0, 0);

        const wrapper = document.createElement('div');
        wrapper.className = 'image-wrapper';
        wrapper.id = "wrapperid";
        wrapper.appendChild(canvas);
        canvas.id = "canvasid1";
        wrapper.appendChild(document.createElement('div')).className = 'keypoints-label';
        mainContainer.appendChild(wrapper);

        // Determine which workers to use based on extreme points

// Determine which workers to use based on extreme points
const legParts = [
    'leftFoot', 'rightFoot',
    'leftUpperLegFront', 'leftUpperLegBack', 
    'leftLowerLegFront', 'leftLowerLegBack',
    'rightUpperLegFront', 'rightUpperLegBack', 
    'rightLowerLegFront', 'rightLowerLegBack'
];

// Check if any leg parts are present
const hasLegParts = legParts.some(part => 
    extremePoints[part] && 
    Object.keys(extremePoints[part]).length > 0
);

// Create workers conditionally
const workersToUse = [];
if (hasLegParts) {
    const legWorker = new Worker('rightarmonlyworker.js');
    workersToUse.push({
        worker: legWorker,
        type: 'leg'
    });
}

numberOfVariations = document.getElementById('imageCount').value;

const workerMessages = workersToUse.map(({type}) => ({
    type: e.data.type,
    imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),
    width: canvas.width,
    height: canvas.height,
    extremePoints,
    averages,
    timestamp: Date.now(),
    partNames,
    numberOfVariations, 
    bodyPartImages,
    rotationAngles: [0, 45, 90, 135, 180],
    imageArray
}));

let accumulatedVariations = [];

let totalVariationsExpected = numberOfVariations;

let totalworkerimages = 2 * numberOfVariations;

const generatedImages = [];
let combinedImagesProcessed = 0;

// Track already processed pairs
const processedPairs = new Set();

function attemptCombination() {
    for (let i = 0; i < totalworkerimages; i += 2) {
        // Stop if we already have the required number of combined images
        if (combinedImagesProcessed >= numberOfVariations) {
            break;
        }

        // Check if the pair has already been processed
        const pairKey = `${i}-${i + 1}`;
        if (generatedImages.length >= i + 2 && !processedPairs.has(pairKey)) {
            combineImagesByIndexes(i, i + 1); // Combine images in pairs
            processedPairs.add(pairKey); // Mark the pair as processed
            combinedImagesProcessed++;
        }
    }
}

// Overwrite the `push` method of the generatedImages array to trigger combination checks dynamically
const originalPush = generatedImages.push;
generatedImages.push = function (...args) {
    originalPush.apply(this, args);
    attemptCombination(); // Check if combinations can be processed
};

function safelyCombineImages(img1, img2) {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = img1.width;
        canvas.height = img1.height;

        ctx.drawImage(img1, 0, 0);

        ctx.globalAlpha = 1;

        const x = (canvas.width - img2.width) / 2;
        const y = (canvas.height - img2.height) / 2;
        ctx.drawImage(img2, x, y);

        ctx.globalAlpha = 1;

        const combinedImg = new Image();
        combinedImg.onload = () => resolve(combinedImg);
        combinedImg.onerror = reject;
        combinedImg.src = canvas.toDataURL();
    });
}

function combineImagesByIndexes(index1, index2) {
    const firstImageType = generatedImages[index1].type;
    const secondImageType = generatedImages[index2].type;

    // console.log(`Attempting to combine - First Type: ${firstImageType}, Second Type: ${secondImageType}`);

    // Prevent combination if types are the same
    if (firstImageType === secondImageType) {
        console.error(`Cannot combine images of the same type: ${firstImageType}`);
        return; // Exit the function immediately
    }

    if (generatedImages.length > Math.max(index1, index2)) {
        const imagePromises = [index1, index2].map(idx => {
            return new Promise((resolve, reject) => {
                const imgInfo = generatedImages[idx];
                const img = new Image();

                if (imgInfo.imageUrl) {
                    img.src = imgInfo.imageUrl;
                } else {
                    try {
                        img.src = createImageFromData(
                            imgInfo.imageData,
                            imgInfo.width,
                            imgInfo.height
                        );
                    } catch (error) {
                        console.error('Error creating image:', error);
                        reject(error);
                        return;
                    }
                }

                img.onload = () => resolve(img);
                img.onerror = reject;
            });
        });

        // Promise.all(imagePromises)
        //     .then(([img1, img2]) => safelyCombineImages(img1, img2))
        //     .then(combinedImg => {
        //         const combinedContainer = document.createElement('div');
        //         combinedContainer.className = 'combined-images-container';

        //         const combinedWrapper = document.createElement('div');
        //         combinedWrapper.className = 'image-wrapper combined';
        //         combinedWrapper.appendChild(combinedImg);

        //         const verificationInfo = document.createElement('div');
        //         verificationInfo.className = 'verification-info';
        //         verificationInfo.innerHTML = `
        //             Combination Verification:
        //             <br>First Image Type: ${generatedImages[index1].type}
        //             <br>Second Image Type: ${generatedImages[index2].type}
        //             <br>First Image Dimensions: ${generatedImages[index1].width}x${generatedImages[index1].height}
        //             <br>Second Image Dimensions: ${generatedImages[index2].width}x${generatedImages[index2].height}
        //             <br>Combined Image Dimensions: ${combinedImg.width}x${combinedImg.height}
        //         `;

        //         combinedContainer.appendChild(verificationInfo);
        //         combinedContainer.appendChild(combinedWrapper);

        //         const container = document.getElementById('imageContainer');
        //         container.appendChild(combinedContainer);

        //         // console.log(`Images at indexes ${index1} and ${index2} combined successfully`);
        //     })
        //     .catch(error => {
        //         console.error(`Error combining images at indexes ${index1} and ${index2}:`, error);

        //         const errorContainer = document.createElement('div');
        //         errorContainer.className = 'verification-info';
        //         errorContainer.textContent = `Error combining images: ${error.message}`;

        //         const container = document.getElementById('imageContainer');
        //         container.appendChild(errorContainer);
        //     });
      
        }
}

// // Worker processing
// Promise.allSettled(
//     workersToUse.map(({ worker }, index) =>
//         new Promise((resolve, reject) => {
//             worker.onmessage = (e) => {
//                 if (e.data.type === 'processedVariations') {
//                     if (!e.data.variations || e.data.variations.length === 0) {
//                         console.warn(`No variations for ${workersToUse[index].type} worker`);
//                         return;
//                     }

//                     workersToUse[index].variations = e.data.variations;

//                     e.data.variations.forEach((variation, variationIndex) => {
//                         const img = document.createElement('img');
//                         img.src = variation.imageUrl || createImageFromData(
//                             variation.imageData,
//                             variation.width,
//                             variation.height
//                         );

//                         const wrapper = document.createElement('div');
//                         wrapper.className = 'image-wrapper';

//                         wrapper.appendChild(img);

//                         const container = document.getElementById('imageContainer');
//                         container.appendChild(wrapper);
//                         // console.log(workersToUse[index].type);
//                         generatedImages.push({
//                             index: variationIndex,
//                             type: workersToUse[index].type,
//                             image: img,
//                             imageUrl: variation.imageUrl,
//                             imageData: variation.imageData,
//                             width: variation.width,
//                             height: variation.height
//                         });
//                         // console.log('generatedImages :>> ', generatedImages);

//                         function displayGeneratedImages() {
//             const imageDisplay = document.getElementById('imageDisplay');
            
//             // Clear previous images
//             imageDisplay.innerHTML = '';

//             // Loop through generated images and create display elements
//             generatedImages.forEach((imageData, index) => {
//                 // Create a container for each image
//                 const imageContainer = document.createElement('div');
//                 imageContainer.classList.add('image-item');

//                 // Create image element
//                 const imgElement = document.createElement('img');
                
//                 // Determine how to set the image source
//                 if (imageData.imageUrl) {
//                     imgElement.src = imageData.imageUrl;
//                 } else if (imageData.imageData) {
//                     // If imageData is a base64 string or Blob
//                     imgElement.src = imageData.imageData;
//                 } else if (imageData.image instanceof HTMLImageElement) {
//                     // If it's an already created image element
//                     imgElement.src = imageData.image.src;
//                 }

//                 // Create additional info paragraph
//                 const infoP = document.createElement('p');
//                 infoP.textContent = `Image ${index + 1} - Type: ${imageData.type}, Width: ${imageData.width}, Height: ${imageData.height}`;

//                 // Append elements
//                 imageContainer.appendChild(imgElement);
//                 imageContainer.appendChild(infoP);
//                 imageDisplay.appendChild(imageContainer);
//             });

//             // Log for debugging
//             // console.log('Generated Images:', generatedImages);
//         }

//         // Call the display function after generating images
//         displayGeneratedImages();
//                     });

//                     resolve({
//                         type: workersToUse[index].type,
//                         variations: e.data.variations
//                     });
//                 }
//             };

//             worker.onerror = (error) => {
//                 console.error('Worker error:', error);
//                 reject(error);
//             };

//             worker.postMessage(workerMessages[index]);
//         })
//     )
// ).catch(error => {
//     console.error('Overall worker processing error:', error);
// });



const imageContainer = document.getElementById('imageContainer');
imageContainer.innerHTML = ''; // Clear existing content
imageContainer.style.position = 'relative';
imageContainer.style.height = '600px'; // Adjust as needed
imageContainer.style.overflow = 'hidden';

// Add styles
const style = document.createElement('style');
style.textContent = `
    #imageContainer {
        position: relative;
        width: 100%;
        margin: 20px 0;
        overflow: hidden;
    }

    .image-wrapper {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
    }

    .image-wrapper.active {
        opacity: 1;
    }

    .image-wrapper img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }
`;
document.head.appendChild(style);

// Promise.allSettled code remains the same
Promise.allSettled(
    workersToUse.map(({ worker }, index) =>
        new Promise((resolve, reject) => {
            worker.onmessage = (e) => {
                if (e.data.type === 'processedVariations') {
                    if (!e.data.variations || e.data.variations.length === 0) {
                        console.warn(`No variations for ${workersToUse[index].type} worker`);
                        return;
                    }

                    workersToUse[index].variations = e.data.variations;

                    e.data.variations.forEach((variation, variationIndex) => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'image-wrapper';
                        
                        const img = document.createElement('img');
                        img.src = variation.imageUrl || createImageFromData(
                            variation.imageData,
                            variation.width,
                            variation.height
                        );

                        wrapper.appendChild(img);
                        imageContainer.appendChild(wrapper);

                        generatedImages.push({
                            index: variationIndex,
                            type: workersToUse[index].type,
                            wrapper: wrapper,
                            image: img
                        });
                    });

                    // Start animation when all workers are done
                    if (index === workersToUse.length - 1) {
                        startSequentialAnimation();
                    }

                    resolve({
                        type: workersToUse[index].type,
                        variations: e.data.variations
                    });
                }
            };

            worker.onerror = (error) => {
                console.error('Worker error:', error);
                reject(error);
            };

            worker.postMessage(workerMessages[index]);
        })
    )
).catch(error => {
    console.error('Overall worker processing error:', error);
});

// Modified sequential animation function for continuous animation
function startSequentialAnimation() {
    let currentIndex = 0;
    
    // First hide all images
    generatedImages.forEach(item => {
        item.wrapper.classList.remove('active');
    });

    function showNextImage() {
        // Hide current image
        if (currentIndex > 0) {
            generatedImages[currentIndex - 1].wrapper.classList.remove('active');
        } else {
            // When starting a new cycle, hide the last image
            generatedImages[generatedImages.length - 1].wrapper.classList.remove('active');
        }

        // Show next image
        generatedImages[currentIndex].wrapper.classList.add('active');

        // Increment counter
        currentIndex = (currentIndex + 1) % generatedImages.length;

        // Schedule next image - animation continues indefinitely
        setTimeout(showNextImage, 200);
    }

    // Start the sequence
    showNextImage();
}


// Helper function to create an image from ImageData
function createImageFromData(imageData, width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    ctx.putImageData(new ImageData(imageData, width, height), 0, 0);
    return canvas.toDataURL();
}


    }
}
}

async function leftarmonly() {

// console.log("1111111111111111");
const img = document.getElementById('sourceImage');
const mainContainer = document.getElementById('mainContainer');
mainContainer.innerHTML = '';

const imageGrid = document.createElement('div');
imageGrid.className = 'image-grid';

const segmentation = segmentationResult;
const bodyPartImages = {};
// collectedPoints.clear();

for (let partId = 0; partId < 24; partId++) {
    const partName = Object.keys(BODY_PARTS)[partId];
    if (!partName) continue;
    if (!segmentation.data.includes(partId)) {

        continue; 
    
    }

    const segmentCanvas = document.createElement('canvas');
    segmentCanvas.width = img.width;
    segmentCanvas.height = img.height;
    // const segmentCtx = segmentCanvas.getContext('2d');
    const segmentCtx = segmentCanvas.getContext('2d', { willReadFrequently: true });
    segmentCtx.drawImage(img, 0, 0);

    const imageData = segmentCtx.getImageData(0, 0, img.width, img.height);
  
    for (let i = 0; i < segmentation.data.length; i++) {
        if (segmentation.data[i] !== partId) imageData.data[i * 4 + 3] = 0;
    }

    const variations = await processSegmentVariations(imageData, partName);
    bodyPartImages[partName] = variations.map(v => ({
        imageData: v.data,
        width: img.width,
        height: img.height,
        extremePoints: v.extremePoints
    }));
}

const pointsToProcess = {
    leftFace: collectedPoints.get('left_face'),
    rightFace: collectedPoints.get('right_face'),
    leftUpperArmFront: collectedPoints.get('left_upper_arm_front'),
    leftUpperArmBack: collectedPoints.get('left_upper_arm_back'),
    leftLowerArmFront: collectedPoints.get('left_lower_arm_front'),
    leftLowerArmBack: collectedPoints.get('left_lower_arm_back'),
    leftHand: collectedPoints.get('left_hand'),
    rightUpperArmFront: collectedPoints.get('right_upper_arm_front'),
    rightUpperArmBack: collectedPoints.get('right_upper_arm_back'),
    rightLowerArmFront: collectedPoints.get('right_lower_arm_front'),
    rightLowerArmBack: collectedPoints.get('right_lower_arm_back'),
    rightHand: collectedPoints.get('right_hand'),
    torsoFront: collectedPoints.get('torso_front'),
    torsoBack: collectedPoints.get('torso_back'),
    leftUpperLegFront: collectedPoints.get('left_upper_leg_front'),
    leftUpperLegBack: collectedPoints.get('left_upper_leg_back'),
    leftLowerLegFront: collectedPoints.get('left_lower_leg_front'),
    leftLowerLegBack: collectedPoints.get('left_lower_leg_back'),
    rightUpperLegFront: collectedPoints.get('right_upper_leg_front'),
    rightUpperLegBack: collectedPoints.get('right_upper_leg_back'),
    rightLowerLegFront: collectedPoints.get('right_lower_leg_front'),
    rightLowerLegBack: collectedPoints.get('right_lower_leg_back'),
    leftFoot: collectedPoints.get('left_foot'),
    rightFoot: collectedPoints.get('right_foot')
};

segmentationWorker.postMessage({
    type: 'calculateAverage',
    points: pointsToProcess,
    bodyPartImages,
    partNames: {
        leftUpperArmFront: 'left_upper_arm_front',
        leftUpperArmBack: 'left_upper_arm_back',
        leftLowerArmFront: 'left_lower_arm_front',
        leftLowerArmBack: 'left_lower_arm_back',
        leftHand: 'left_hand',
        rightUpperArmFront: 'right_upper_arm_front',
        rightUpperArmBack: 'right_upper_arm_back',
        rightLowerArmFront: 'right_lower_arm_front',
        rightLowerArmBack: 'right_lower_arm_back',
        rightHand: 'right_hand',
        leftFoot: 'left_foot',
        rightFoot: 'right_foot',
        leftUpperFoot: 'left_upper_foot',
        leftLowerFoot: 'left_lower_foot',
        rightUpperFoot: 'right_upper_foot',
        rightLowerFoot: 'right_lower_foot',
        leftUpperLegFront: 'left_upper_leg_front',
        leftUpperLegBack: 'left_upper_leg_back',
        leftLowerLegFront: 'left_lower_leg_front',
        leftLowerLegBack: 'left_lower_leg_back',
        rightUpperLegFront: 'right_upper_leg_front',
        rightUpperLegBack: 'right_upper_leg_back',
        rightLowerLegFront: 'right_lower_leg_front',
        rightLowerLegBack: 'right_lower_leg_back'
    },
    offset: { x: 100, y: 50 },
    imageArray
}); 

segmentationWorker.onmessage = e => {
    const { type, averages, extremePoints, partNames } = e.data;
    // console.log(e.data);
    if (type === 'combinedResults' && (averages || extremePoints)) {
        
        processedData = {
            averages,
            extremePoints,
            partNames,
            timestamp: Date.now()
        };

        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        // const ctx = canvas.getContext('2d');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.drawImage(img, 0, 0);

        const wrapper = document.createElement('div');
        wrapper.className = 'image-wrapper';
        wrapper.id = "wrapperid";
        wrapper.appendChild(canvas);
        canvas.id = "canvasid1";
        wrapper.appendChild(document.createElement('div')).className = 'keypoints-label';
        mainContainer.appendChild(wrapper);

        // Determine which workers to use based on extreme points

// Determine which workers to use based on extreme points
const legParts = [
    'leftFoot', 'rightFoot',
    'leftUpperLegFront', 'leftUpperLegBack', 
    'leftLowerLegFront', 'leftLowerLegBack',
    'rightUpperLegFront', 'rightUpperLegBack', 
    'rightLowerLegFront', 'rightLowerLegBack'
];

// Check if any leg parts are present
const hasLegParts = legParts.some(part => 
    extremePoints[part] && 
    Object.keys(extremePoints[part]).length > 0
);

// Create workers conditionally
const workersToUse = [];
if (hasLegParts) {
    const legWorker = new Worker('leftarmonlyworker.js');
    workersToUse.push({
        worker: legWorker,
        type: 'leg'
    });
}

numberOfVariations = document.getElementById('imageCount').value;

const workerMessages = workersToUse.map(({type}) => ({
    type: e.data.type,
    imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),
    width: canvas.width,
    height: canvas.height,
    extremePoints,
    averages,
    timestamp: Date.now(),
    partNames,
    numberOfVariations, 
    bodyPartImages,
    rotationAngles: [0, 45, 90, 135, 180],
    imageArray
}));

let accumulatedVariations = [];

let totalVariationsExpected = numberOfVariations;

let totalworkerimages = 2 * numberOfVariations;

const generatedImages = [];
let combinedImagesProcessed = 0;

// Track already processed pairs
const processedPairs = new Set();

function attemptCombination() {
    for (let i = 0; i < totalworkerimages; i += 2) {
        // Stop if we already have the required number of combined images
        if (combinedImagesProcessed >= numberOfVariations) {
            break;
        }

        // Check if the pair has already been processed
        const pairKey = `${i}-${i + 1}`;
        if (generatedImages.length >= i + 2 && !processedPairs.has(pairKey)) {
            combineImagesByIndexes(i, i + 1); // Combine images in pairs
            processedPairs.add(pairKey); // Mark the pair as processed
            combinedImagesProcessed++;
        }
    }
}

// Overwrite the `push` method of the generatedImages array to trigger combination checks dynamically
const originalPush = generatedImages.push;
generatedImages.push = function (...args) {
    originalPush.apply(this, args);
    attemptCombination(); // Check if combinations can be processed
};

function safelyCombineImages(img1, img2) {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = img1.width;
        canvas.height = img1.height;

        ctx.drawImage(img1, 0, 0);

        ctx.globalAlpha = 1;

        const x = (canvas.width - img2.width) / 2;
        const y = (canvas.height - img2.height) / 2;
        ctx.drawImage(img2, x, y);

        ctx.globalAlpha = 1;

        const combinedImg = new Image();
        combinedImg.onload = () => resolve(combinedImg);
        combinedImg.onerror = reject;
        combinedImg.src = canvas.toDataURL();
    });
}

function combineImagesByIndexes(index1, index2) {
    const firstImageType = generatedImages[index1].type;
    const secondImageType = generatedImages[index2].type;

    // console.log(`Attempting to combine - First Type: ${firstImageType}, Second Type: ${secondImageType}`);

    // Prevent combination if types are the same
    if (firstImageType === secondImageType) {
        console.error(`Cannot combine images of the same type: ${firstImageType}`);
        return; // Exit the function immediately
    }

    if (generatedImages.length > Math.max(index1, index2)) {
        const imagePromises = [index1, index2].map(idx => {
            return new Promise((resolve, reject) => {
                const imgInfo = generatedImages[idx];
                const img = new Image();

                if (imgInfo.imageUrl) {
                    img.src = imgInfo.imageUrl;
                } else {
                    try {
                        img.src = createImageFromData(
                            imgInfo.imageData,
                            imgInfo.width,
                            imgInfo.height
                        );
                    } catch (error) {
                        console.error('Error creating image:', error);
                        reject(error);
                        return;
                    }
                }

                img.onload = () => resolve(img);
                img.onerror = reject;
            });
        });

        // Promise.all(imagePromises)
        //     .then(([img1, img2]) => safelyCombineImages(img1, img2))
        //     .then(combinedImg => {
        //         const combinedContainer = document.createElement('div');
        //         combinedContainer.className = 'combined-images-container';

        //         const combinedWrapper = document.createElement('div');
        //         combinedWrapper.className = 'image-wrapper combined';
        //         combinedWrapper.appendChild(combinedImg);

        //         const verificationInfo = document.createElement('div');
        //         verificationInfo.className = 'verification-info';
        //         verificationInfo.innerHTML = `
        //             Combination Verification:
        //             <br>First Image Type: ${generatedImages[index1].type}
        //             <br>Second Image Type: ${generatedImages[index2].type}
        //             <br>First Image Dimensions: ${generatedImages[index1].width}x${generatedImages[index1].height}
        //             <br>Second Image Dimensions: ${generatedImages[index2].width}x${generatedImages[index2].height}
        //             <br>Combined Image Dimensions: ${combinedImg.width}x${combinedImg.height}
        //         `;

        //         combinedContainer.appendChild(verificationInfo);
        //         combinedContainer.appendChild(combinedWrapper);

        //         const container = document.getElementById('imageContainer');
        //         container.appendChild(combinedContainer);

        //         // console.log(`Images at indexes ${index1} and ${index2} combined successfully`);
        //     })
        //     .catch(error => {
        //         console.error(`Error combining images at indexes ${index1} and ${index2}:`, error);

        //         const errorContainer = document.createElement('div');
        //         errorContainer.className = 'verification-info';
        //         errorContainer.textContent = `Error combining images: ${error.message}`;

        //         const container = document.getElementById('imageContainer');
        //         container.appendChild(errorContainer);
        //     });
      
        }
}

const imageContainer = document.getElementById('imageContainer');
imageContainer.innerHTML = ''; // Clear existing content
imageContainer.style.position = 'relative';
imageContainer.style.height = '600px'; // Adjust as needed
imageContainer.style.overflow = 'hidden';

// Add styles
const style = document.createElement('style');
style.textContent = `
    #imageContainer {
        position: relative;
        width: 100%;
        margin: 20px 0;
        overflow: hidden;
    }

    .image-wrapper {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        }

    .image-wrapper.active {
        opacity: 1;
    }

    .image-wrapper img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }
`;
document.head.appendChild(style);

// Promise.allSettled code remains the same
Promise.allSettled(
    workersToUse.map(({ worker }, index) =>
        new Promise((resolve, reject) => {
            worker.onmessage = (e) => {
                if (e.data.type === 'processedVariations') {
                    if (!e.data.variations || e.data.variations.length === 0) {
                        console.warn(`No variations for ${workersToUse[index].type} worker`);
                        return;
                    }

                    workersToUse[index].variations = e.data.variations;

                    e.data.variations.forEach((variation, variationIndex) => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'image-wrapper';
                        
                        const img = document.createElement('img');
                        img.src = variation.imageUrl || createImageFromData(
                            variation.imageData,
                            variation.width,
                            variation.height
                        );

                        wrapper.appendChild(img);
                        imageContainer.appendChild(wrapper);

                        generatedImages.push({
                            index: variationIndex,
                            type: workersToUse[index].type,
                            wrapper: wrapper,
                            image: img
                        });
                    });

                    // Start animation when all workers are done
                    if (index === workersToUse.length - 1) {
                        startSequentialAnimation();
                    }

                    resolve({
                        type: workersToUse[index].type,
                        variations: e.data.variations
                    });
                }
            };

            worker.onerror = (error) => {
                console.error('Worker error:', error);
                reject(error);
            };

            worker.postMessage(workerMessages[index]);
        })
    )
).catch(error => {
    console.error('Overall worker processing error:', error);
});

// Modified sequential animation function for continuous animation
function startSequentialAnimation() {
    let currentIndex = 0;
    
    // First hide all images
    generatedImages.forEach(item => {
        item.wrapper.classList.remove('active');
    });

    function showNextImage() {
        // Hide current image
        if (currentIndex > 0) {
            generatedImages[currentIndex - 1].wrapper.classList.remove('active');
        } else {
            // When starting a new cycle, hide the last image
            generatedImages[generatedImages.length - 1].wrapper.classList.remove('active');
        }

        // Show next image
        generatedImages[currentIndex].wrapper.classList.add('active');

        // Increment counter
        currentIndex = (currentIndex + 1) % generatedImages.length;

        // Schedule next image - animation continues indefinitely
        setTimeout(showNextImage, 200);
    }

    // Start the sequence
    showNextImage();
}

// // Worker processing
// Promise.allSettled(
//     workersToUse.map(({ worker }, index) =>
//         new Promise((resolve, reject) => {
//             worker.onmessage = (e) => {
//                 if (e.data.type === 'processedVariations') {
//                     if (!e.data.variations || e.data.variations.length === 0) {
//                         console.warn(`No variations for ${workersToUse[index].type} worker`);
//                         return;
//                     }

//                     workersToUse[index].variations = e.data.variations;

//                     e.data.variations.forEach((variation, variationIndex) => {
//                         const img = document.createElement('img');
//                         img.src = variation.imageUrl || createImageFromData(
//                             variation.imageData,
//                             variation.width,
//                             variation.height
//                         );

//                         const wrapper = document.createElement('div');
//                         wrapper.className = 'image-wrapper';

//                         wrapper.appendChild(img);

//                         const container = document.getElementById('imageContainer');
//                         container.appendChild(wrapper);
//                         // console.log(workersToUse[index].type);
//                         generatedImages.push({
//                             index: variationIndex,
//                             type: workersToUse[index].type,
//                             image: img,
//                             imageUrl: variation.imageUrl,
//                             imageData: variation.imageData,
//                             width: variation.width,
//                             height: variation.height
//                         });
//                         // console.log('generatedImages :>> ', generatedImages);
//                     });

//                     resolve({
//                         type: workersToUse[index].type,
//                         variations: e.data.variations
//                     });
//                 }
//             };

//             worker.onerror = (error) => {
//                 console.error('Worker error:', error);
//                 reject(error);
//             };

//             worker.postMessage(workerMessages[index]);
//         })
//     )
// ).catch(error => {
//     console.error('Overall worker processing error:', error);
// });

// Helper function to create an image from ImageData
function createImageFromData(imageData, width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    ctx.putImageData(new ImageData(imageData, width, height), 0, 0);
    return canvas.toDataURL();
}


    }
}
}

function startProcessing(processType) {
    console.log("323232323");
    if (!segmentationResult) {
        alert('Segmentation not ready. Please wait.');
        return;
    }
    count = 1    
    // Clear imageArray before starting new processing
    imageArray = [];
    if (!window.imageArrayCollection) {
        window.imageArrayCollection = [];
    }
// alert(processType)
        processImageWithOverlay(processType);
        console.log("object");

}



function startProcessing1(processType) {
    console.log("12121212121");
    if (!segmentationResult) {
        alert('Segmentation not ready. Please wait.');
        return;
    }
    count = 1;    
    // Clear imageArray before starting new processing
    imageArray = [];
    if (!window.imageArrayCollection) {
        window.imageArrayCollection = [];
    }
    processImageWithOverlay1(processType);
    console.log("object");
}


async function loadModels() {
    net = await bodyPix.load({
        architecture: 'MobileNetV1',
        outputStride: 16,
        multiplier: 0.75,
        quantBytes: 2
    });
}

async function processImageWithOverlay(processType) {
    const img = document.getElementById('sourceImage');
    const mainContainer = document.getElementById('mainContainer');
    mainContainer.innerHTML = '';
    const imageContainer = document.createElement('div');
    imageContainer.className = 'image-sequence-container';
    imageContainer.style.position = 'relative';
    mainContainer.appendChild(imageContainer);
    
    const imageGrid = document.createElement('div');
    imageGrid.className = 'image-grid';

    const segmentation = segmentationResult;
    const bodyPartImages = {};

    for (let partId = 0; partId < 24; partId++) {
        const partName = Object.keys(BODY_PARTS)[partId];
        if (!partName) continue;
        if (!segmentation.data.includes(partId)) {

            continue; // Skip processing if part is not present
        }

        const segmentCanvas = document.createElement('canvas');
        segmentCanvas.width = img.width;
        segmentCanvas.height = img.height;
        // const segmentCtx = segmentCanvas.getContext('2d');
        const segmentCtx = segmentCanvas.getContext('2d', { willReadFrequently: true });
        segmentCtx.drawImage(img, 0, 0);

        const imageData = segmentCtx.getImageData(0, 0, img.width, img.height);
      
        for (let i = 0; i < segmentation.data.length; i++) {
            if (segmentation.data[i] !== partId) imageData.data[i * 4 + 3] = 0;
        }

        const variations = await processSegmentVariations(imageData, partName);
        bodyPartImages[partName] = variations.map(v => ({
            imageData: v.data,
            width: img.width,
            height: img.height,
            extremePoints: v.extremePoints
        }));
    }
    
    const pointsToProcess = {
        leftFace: collectedPoints.get('left_face'),
        rightFace: collectedPoints.get('right_face'),
        leftUpperArmFront: collectedPoints.get('left_upper_arm_front'),
        leftUpperArmBack: collectedPoints.get('left_upper_arm_back'),
        leftLowerArmFront: collectedPoints.get('left_lower_arm_front'),
        leftLowerArmBack: collectedPoints.get('left_lower_arm_back'),
        leftHand: collectedPoints.get('left_hand'),
        rightUpperArmFront: collectedPoints.get('right_upper_arm_front'),
        rightUpperArmBack: collectedPoints.get('right_upper_arm_back'),
        rightLowerArmFront: collectedPoints.get('right_lower_arm_front'),
        rightLowerArmBack: collectedPoints.get('right_lower_arm_back'),
        rightHand: collectedPoints.get('right_hand'),
        torsoFront: collectedPoints.get('torso_front'),
        torsoBack: collectedPoints.get('torso_back'),
        leftUpperLegFront: collectedPoints.get('left_upper_leg_front'),
        leftUpperLegBack: collectedPoints.get('left_upper_leg_back'),
        leftLowerLegFront: collectedPoints.get('left_lower_leg_front'),
        leftLowerLegBack: collectedPoints.get('left_lower_leg_back'),
        rightUpperLegFront: collectedPoints.get('right_upper_leg_front'),
        rightUpperLegBack: collectedPoints.get('right_upper_leg_back'),
        rightLowerLegFront: collectedPoints.get('right_lower_leg_front'),
        rightLowerLegBack: collectedPoints.get('right_lower_leg_back'),
        leftFoot: collectedPoints.get('left_foot'),
        rightFoot: collectedPoints.get('right_foot')
    };

    segmentationWorker.postMessage({
        type: 'calculateAverage',
        points: pointsToProcess,
        bodyPartImages,
        partNames: {
            leftUpperArmFront: 'left_upper_arm_front',
            leftUpperArmBack: 'left_upper_arm_back',
            leftLowerArmFront: 'left_lower_arm_front',
            leftLowerArmBack: 'left_lower_arm_back',
            leftHand: 'left_hand',
            rightUpperArmFront: 'right_upper_arm_front',
            rightUpperArmBack: 'right_upper_arm_back',
            rightLowerArmFront: 'right_lower_arm_front',
            rightLowerArmBack: 'right_lower_arm_back',
            rightHand: 'right_hand',
            leftFoot: 'left_foot',
            rightFoot: 'right_foot',
            leftUpperFoot: 'left_upper_foot',
            leftLowerFoot: 'left_lower_foot',
            rightUpperFoot: 'right_upper_foot',
            rightLowerFoot: 'right_lower_foot',
            leftUpperLegFront: 'left_upper_leg_front',
            leftUpperLegBack: 'left_upper_leg_back',
            leftLowerLegFront: 'left_lower_leg_front',
            leftLowerLegBack: 'left_lower_leg_back',
            rightUpperLegFront: 'right_upper_leg_front',
            rightUpperLegBack: 'right_upper_leg_back',
            rightLowerLegFront: 'right_lower_leg_front',
            rightLowerLegBack: 'right_lower_leg_back'
        },
        offset: { x: 100, y: 50 },
        imageArray
    }); 

    segmentationWorker.onmessage = e => {
        const { type, averages, extremePoints, partNames } = e.data;
        
        if (type === 'combinedResults' && (averages || extremePoints)) {
            
            processedData = {
                averages,
                extremePoints,
                partNames,
                timestamp: Date.now()
            };

            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            // const ctx = canvas.getContext('2d');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(img, 0, 0);

        const wrapper = document.createElement('div');
        wrapper.className = 'image-wrapper';
        // wrapper.id = "wrapperid";
        wrapper.appendChild(canvas);
        canvas.id = "canvasid1";
        wrapper.appendChild(document.createElement('div')).className = 'keypoints-label';
        // mainContainer.appendChild(wrapper);

// Determine which workers to use based on extreme points
const handParts = [
    'leftHand', 'rightHand', 
    'leftUpperArmFront', 'leftUpperArmBack', 
    'leftLowerArmFront', 'leftLowerArmBack',
    'rightUpperArmFront', 'rightUpperArmBack', 
    'rightLowerArmFront', 'rightLowerArmBack'
];

const legParts = [
    'leftFoot', 'rightFoot',
    'leftUpperLegFront', 'leftUpperLegBack', 
    'leftLowerLegFront', 'leftLowerLegBack',
    'rightUpperLegFront', 'rightUpperLegBack', 
    'rightLowerLegFront', 'rightLowerLegBack'
];

// Check if any hand or leg parts are present
const hasHandParts = handParts.some(part => 
    extremePoints[part] && 
    Object.keys(extremePoints[part]).length > 0
);

const hasLegParts = legParts.some(part => 
    extremePoints[part] && 
    Object.keys(extremePoints[part]).length > 0
);

const workersToUse = [];
if (hasHandParts) {
    const postprocessingWorker = new Worker('handworker.js');
    workersToUse.push({
        worker: postprocessingWorker,
        type: 'hand'
    });
}

if (hasLegParts) {
    const legWorker = new Worker('legworker.js');
    workersToUse.push({
        worker: legWorker,
        type: 'leg'
    });
}

numberOfVariations = document.getElementById('imageCount').value;

const workerMessages = workersToUse.map(({type}) => ({
    type: e.data.type,
    imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),
    width: canvas.width,
    height: canvas.height,
    extremePoints,
    averages,
    timestamp: Date.now(),
    partNames,
    numberOfVariations, 
    bodyPartImages,
    rotationAngles: [0, 45, 90, 135, 180],
    imageArray
}));

let accumulatedVariations = [];

let totalVariationsExpected = numberOfVariations; // Assuming this is correctly set before processing starts

let totalworkerimages = 2 * numberOfVariations;

const generatedImages = [];
let combinedImagesProcessed = 0;

// Track already processed pairs
const processedPairs = new Set();

function attemptCombination() {
    for (let i = 0; i < totalworkerimages; i += 2) {
        // Stop if we already have the required number of combined images
        if (combinedImagesProcessed >= numberOfVariations) {
            break;
        }

        // Check if the pair has already been processed
        const pairKey = `${i}-${i + 1}`;
        if (generatedImages.length >= i + 2 && !processedPairs.has(pairKey)) {
            combineImagesByIndexes(i, i + 1); // Combine images in pairs
            processedPairs.add(pairKey); // Mark the pair as processed
            combinedImagesProcessed++;
        }
    }
}

// Overwrite the `push` method of the generatedImages array to trigger combination checks dynamically
const originalPush = generatedImages.push;
generatedImages.push = function (...args) {
    originalPush.apply(this, args);
    attemptCombination(); // Check if combinations can be processed
};
console.log('generatedImages :>> ', generatedImages);


function safelyCombineImages(img1, img2) {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = img1.width;
        canvas.height = img1.height;

        ctx.drawImage(img1, 0, 0);

        ctx.globalAlpha = 1;

        const x = (canvas.width - img2.width) / 2;
        const y = (canvas.height - img2.height) / 2;
        ctx.drawImage(img2, x, y);

        ctx.globalAlpha = 1;

        const combinedImg = new Image();
        combinedImg.onload = () => resolve(combinedImg);
        combinedImg.onerror = reject;
        combinedImg.src = canvas.toDataURL();
    });
}

function combineImagesByIndexes(index1, index2) {
    
    const firstImageType = generatedImages[index1].type;
    const secondImageType = generatedImages[index2].type;

    // console.log(`Attempting to combine - First Type: ${firstImageType}, Second Type: ${secondImageType}`);

    // Prevent combination if types are the same
    // if (firstImageType === secondImageType) {
    //     console.error(`Cannot combine images of the same type: ${firstImageType}`);
    //     return; // Exit the function immediately
    // }

    
    // if (generatedImages.length > Math.max(index1, index2)) {
    //     const imagePromises = [index1, index2].map(idx => {
    //         return new Promise((resolve, reject) => {
    //             const imgInfo = generatedImages[idx];
    //             const img = new Image();
    //             // // console.log('img :>> ', img);

    //             if (imgInfo.imageUrl) {
    //                 img.src = imgInfo.imageUrl;
    //             } else {
    //                 try {
    //                     img.src = createImageFromData(
    //                         imgInfo.imageData,
    //                         imgInfo.width,
    //                         imgInfo.height
    //                     );
    //                 } catch (error) {
    //                     console.error('Error creating image:', error);
    //                     reject(error);
    //                     return;
    //                 }
    //             }

    //             img.onload = () => resolve(img);
    //             img.onerror = reject;
    //         });
    //     });

    //     Promise.all(imagePromises)
    //         .then(([img1, img2]) => safelyCombineImages(img1, img2))
    //         .then(combinedImg => {
    //             const combinedContainer = document.createElement('div');
    //             combinedContainer.className = 'combined-images-container';

    //             const combinedWrapper = document.createElement('div');
    //             combinedWrapper.className = 'image-wrapper combined';
    //             combinedWrapper.appendChild(combinedImg);

    //             const verificationInfo = document.createElement('div');
    //             verificationInfo.className = 'verification-info';

    //             combinedContainer.appendChild(verificationInfo);
    //             combinedContainer.appendChild(combinedWrapper);

    //             const container = document.getElementById('imageContainer');
    //             container.appendChild(combinedContainer);

    //             // console.log(`Images at indexes ${index1} and ${index2} combined successfully`);
    //         })
    //         .catch(error => {
    //             console.error(`Error combining images at indexes ${index1} and ${index2}:`, error);

    //             const errorContainer = document.createElement('div');
    //             errorContainer.className = 'verification-info';
    //             errorContainer.textContent = `Error combining images: ${error.message}`;

    //             const container = document.getElementById('imageContainer');
    //             container.appendChild(errorContainer);
    //         });
      
    //     }


    }

// Worker processing remains unchanged
// Promise.allSettled(
//     workersToUse.map(({ worker }, index) =>
//         new Promise((resolve, reject) => {
//             worker.onmessage = (e) => {
//                 if (e.data.type === 'processedVariations') {
//                     if (!e.data.variations || e.data.variations.length === 0) {
//                         console.warn(`No variations for ${workersToUse[index].type} worker`);
//                         return;
//                     }

//                     workersToUse[index].variations = e.data.variations;

//                     e.data.variations.forEach((variation, variationIndex) => {
//                         const img = document.createElement('img');
//                         img.src = variation.imageUrl || createImageFromData(
//                             variation.imageData,
//                             variation.width,
//                             variation.height
//                         );

//                         const wrapper = document.createElement('div');
//                         wrapper.className = 'image-wrapper';

//                         wrapper.appendChild(img);

//                         const container = document.getElementById('imageContainer');
//                         container.appendChild(wrapper);
//                         // console.log(workersToUse[index].type);
//                         generatedImages.push({
//                             index: variationIndex,
//                             type: workersToUse[index].type,
//                             image: img,
//                             imageUrl: variation.imageUrl,
//                             imageData: variation.imageData,
//                             width: variation.width,
//                             height: variation.height
//                         });
//                         // console.log('generatedImages :>> ', generatedImages);
//                     });

//                     resolve({
//                         type: workersToUse[index].type,
//                         variations: e.data.variations
//                     });
//                 }
//             };

//             worker.onerror = (error) => {
//                 console.error('Worker error:', error);
//                 reject(error);
//             };

//             worker.postMessage(workerMessages[index]);
//         })
//     )
// ).catch(error => {
//     console.error('Overall worker processing error:', error);
// });

const imageContainer = document.getElementById('imageContainer');
imageContainer.innerHTML = ''; // Clear existing content
imageContainer.style.position = 'relative';
imageContainer.style.height = '600px'; // Adjust as needed
imageContainer.style.overflow = 'hidden';

// Add styles
const style = document.createElement('style');
style.textContent = `
    #imageContainer {
        position: relative;
        width: 100%;
        margin: 20px 0;
        overflow: hidden;
    }

    .image-wrapper {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
     
    }

    .image-wrapper.active {
        opacity: 1;
    }

    .image-wrapper img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }
`;
document.head.appendChild(style);

// Promise.allSettled code remains the same
Promise.allSettled(
    workersToUse.map(({ worker }, index) =>
        new Promise((resolve, reject) => {
            worker.onmessage = (e) => {
                if (e.data.type === 'processedVariations') {
                    if (!e.data.variations || e.data.variations.length === 0) {
                        console.warn(`No variations for ${workersToUse[index].type} worker`);
                        return;
                    }

                    workersToUse[index].variations = e.data.variations;

                    e.data.variations.forEach((variation, variationIndex) => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'image-wrapper';
                        
                        const img = document.createElement('img');
                        img.src = variation.imageUrl || createImageFromData(
                            variation.imageData,
                            variation.width,
                            variation.height
                        );

                        wrapper.appendChild(img);
                        imageContainer.appendChild(wrapper);

                        generatedImages.push({
                            index: variationIndex,
                            type: workersToUse[index].type,
                            wrapper: wrapper,
                            image: img
                        });
                    });

                    // Start animation when all workers are done
                    if (index === workersToUse.length - 1) {
                        startSequentialAnimation();
                    }

                    resolve({
                        type: workersToUse[index].type,
                        variations: e.data.variations
                    });
                }
            };

            worker.onerror = (error) => {
                console.error('Worker error:', error);
                reject(error);
            };

            worker.postMessage(workerMessages[index]);
        })
    )
).catch(error => {
    console.error('Overall worker processing error:', error);
});



// function startSequentialAnimation() {
//     let currentIndex = 0;
    
//     // First hide all images
//     generatedImages.forEach(item => {
//         item.wrapper.classList.remove('active');
//     });

//     function showNextImage() {
//         // Hide current image
//         if (currentIndex > 0) {
//             generatedImages[currentIndex - 1].wrapper.classList.remove('active');
//         } else {
//             // When starting a new cycle, hide the last image
//             generatedImages[generatedImages.length - 1].wrapper.classList.remove('active');
//         }

//         // Show next image
//         generatedImages[currentIndex].wrapper.classList.add('active');

//         // Increment counter
//         currentIndex = (currentIndex + 1) % generatedImages.length;

//         // Schedule next image - animation continues indefinitely
//         setTimeout(showNextImage, 200);
//     }

//     // Start the sequence
//     showNextImage();
// }




// Helper function to create an image from ImageData


function startSequentialAnimation() {
    // Create a canvas for combining images
    const combinedCanvas = document.createElement('canvas');
    const ctx = combinedCanvas.getContext('2d');
    
    // Set canvas dimensions based on original image size
    combinedCanvas.width = generatedImages[0].image.width;
    combinedCanvas.height = generatedImages[0].image.height;
    
    // Group images by type
    const handImages = generatedImages.filter(img => img.type === 'hand');
    const legImages = generatedImages.filter(img => img.type === 'leg');
    
    // Create wrapper for combined images
    const combinedWrapper = document.createElement('div');
    combinedWrapper.className = 'image-wrapper active';
    imageContainer.appendChild(combinedWrapper);
    
    function combineAndShowImages(handIndex = 0, legIndex = 0) {
        // Clear canvas
        ctx.clearRect(0, 0, combinedCanvas.width, combinedCanvas.height);
        
        // Draw hand image
        if (handImages[handIndex]) {
            ctx.globalAlpha = 1;
            ctx.drawImage(handImages[handIndex].image, 0, 0);
        }
        
        // Draw leg image
        if (legImages[legIndex]) {
            ctx.globalAlpha = 1;
            ctx.drawImage(legImages[legIndex].image, 0, 0);
        }
        
        // Create combined image
        const combinedImage = new Image();
        combinedImage.src = combinedCanvas.toDataURL();
        
        // Update display
        combinedWrapper.innerHTML = '';
        combinedWrapper.appendChild(combinedImage);
        
        // Schedule next combination if needed
        setTimeout(() => {
            const nextHandIndex = (handIndex + 1) % handImages.length;
            const nextLegIndex = (legIndex + 1) % legImages.length;
            combineAndShowImages(nextHandIndex, nextLegIndex);
        }, 200);
    }
    
    // Start the combination process
    combineAndShowImages();
}



// Update the worker processing section
Promise.allSettled(
    workersToUse.map(({ worker }, index) =>
        new Promise((resolve, reject) => {
            worker.onmessage = (e) => {
                if (e.data.type === 'processedVariations') {
                    if (!e.data.variations || e.data.variations.length === 0) {
                        console.warn(`No variations for ${workersToUse[index].type} worker`);
                        return;
                    }

                    workersToUse[index].variations = e.data.variations;

                    e.data.variations.forEach((variation, variationIndex) => {
                        const img = new Image();
                        img.src = variation.imageUrl || createImageFromData(
                            variation.imageData,
                            variation.width,
                            variation.height
                        );

                        generatedImages.push({
                            index: variationIndex,
                            type: workersToUse[index].type,
                            image: img,
                            width: variation.width,
                            height: variation.height
                        });
                    });

                    // Start animation when all workers are done
                    if (generatedImages.length === totalworkerimages) {
                        startSequentialAnimation();
                    }

                    resolve({
                        type: workersToUse[index].type,
                        variations: e.data.variations
                    });
                }
            };

            worker.onerror = (error) => {
                console.error('Worker error:', error);
                reject(error);
            };

            worker.postMessage(workerMessages[index]);
        })
    )
).catch(error => {
    console.error('Overall worker processing error:', error);
});

function createImageFromData(imageData, width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    ctx.putImageData(new ImageData(imageData, width, height), 0, 0);
    return canvas.toDataURL();
}

}
 
    };




}

async function processImageWithOverlay1(processType) {
    const img = document.getElementById('sourceImage');
    const mainContainer = document.getElementById('mainContainer');
    mainContainer.innerHTML = '';
    const imageContainer = document.createElement('div');
    imageContainer.className = 'image-sequence-container';
    imageContainer.style.position = 'relative';
    mainContainer.appendChild(imageContainer);
    
    const imageGrid = document.createElement('div');
    imageGrid.className = 'image-grid';

    const segmentation = segmentationResult;
    const bodyPartImages = {};

    for (let partId = 0; partId < 24; partId++) {
        const partName = Object.keys(BODY_PARTS)[partId];
        if (!partName) continue;
        if (!segmentation.data.includes(partId)) {

            continue; 

        }

        const segmentCanvas = document.createElement('canvas');
        segmentCanvas.width = img.width;
        segmentCanvas.height = img.height;
        // const segmentCtx = segmentCanvas.getContext('2d');
        const segmentCtx = segmentCanvas.getContext('2d', { willReadFrequently: true });
        segmentCtx.drawImage(img, 0, 0);

        const imageData = segmentCtx.getImageData(0, 0, img.width, img.height);
      
        for (let i = 0; i < segmentation.data.length; i++) {
            if (segmentation.data[i] !== partId) imageData.data[i * 4 + 3] = 0;
        }

        const variations = await processSegmentVariations(imageData, partName);
        bodyPartImages[partName] = variations.map(v => ({
            imageData: v.data,
            width: img.width,
            height: img.height,
            extremePoints: v.extremePoints
        }));
    }
    
    const pointsToProcess = {
        leftFace: collectedPoints.get('left_face'),
        rightFace: collectedPoints.get('right_face'),
        leftUpperArmFront: collectedPoints.get('left_upper_arm_front'),
        leftUpperArmBack: collectedPoints.get('left_upper_arm_back'),
        leftLowerArmFront: collectedPoints.get('left_lower_arm_front'),
        leftLowerArmBack: collectedPoints.get('left_lower_arm_back'),
        leftHand: collectedPoints.get('left_hand'),
        rightUpperArmFront: collectedPoints.get('right_upper_arm_front'),
        rightUpperArmBack: collectedPoints.get('right_upper_arm_back'),
        rightLowerArmFront: collectedPoints.get('right_lower_arm_front'),
        rightLowerArmBack: collectedPoints.get('right_lower_arm_back'),
        rightHand: collectedPoints.get('right_hand'),
        torsoFront: collectedPoints.get('torso_front'),
        torsoBack: collectedPoints.get('torso_back'),
        leftUpperLegFront: collectedPoints.get('left_upper_leg_front'),
        leftUpperLegBack: collectedPoints.get('left_upper_leg_back'),
        leftLowerLegFront: collectedPoints.get('left_lower_leg_front'),
        leftLowerLegBack: collectedPoints.get('left_lower_leg_back'),
        rightUpperLegFront: collectedPoints.get('right_upper_leg_front'),
        rightUpperLegBack: collectedPoints.get('right_upper_leg_back'),
        rightLowerLegFront: collectedPoints.get('right_lower_leg_front'),
        rightLowerLegBack: collectedPoints.get('right_lower_leg_back'),
        leftFoot: collectedPoints.get('left_foot'),
        rightFoot: collectedPoints.get('right_foot')
    };

    segmentationWorker.postMessage({
        type: 'calculateAverage',
        points: pointsToProcess,
        bodyPartImages,
        partNames: {
            leftUpperArmFront: 'left_upper_arm_front',
            leftUpperArmBack: 'left_upper_arm_back',
            leftLowerArmFront: 'left_lower_arm_front',
            leftLowerArmBack: 'left_lower_arm_back',
            leftHand: 'left_hand',
            rightUpperArmFront: 'right_upper_arm_front',
            rightUpperArmBack: 'right_upper_arm_back',
            rightLowerArmFront: 'right_lower_arm_front',
            rightLowerArmBack: 'right_lower_arm_back',
            rightHand: 'right_hand',
            leftFoot: 'left_foot',
            rightFoot: 'right_foot',
            leftUpperFoot: 'left_upper_foot',
            leftLowerFoot: 'left_lower_foot',
            rightUpperFoot: 'right_upper_foot',
            rightLowerFoot: 'right_lower_foot',
            leftUpperLegFront: 'left_upper_leg_front',
            leftUpperLegBack: 'left_upper_leg_back',
            leftLowerLegFront: 'left_lower_leg_front',
            leftLowerLegBack: 'left_lower_leg_back',
            rightUpperLegFront: 'right_upper_leg_front',
            rightUpperLegBack: 'right_upper_leg_back',
            rightLowerLegFront: 'right_lower_leg_front',
            rightLowerLegBack: 'right_lower_leg_back'
        },
        offset: { x: 100, y: 50 },
        imageArray
    }); 

    segmentationWorker.onmessage = e => {
        const { type, averages, extremePoints, partNames } = e.data;
        
        if (type === 'combinedResults' && (averages || extremePoints)) {
            
            processedData = {
                averages,
                extremePoints,
                partNames,
                timestamp: Date.now()
            };

            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            // const ctx = canvas.getContext('2d');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(img, 0, 0);

        const wrapper = document.createElement('div');
        wrapper.className = 'image-wrapper';
        // wrapper.id = "wrapperid";
        wrapper.appendChild(canvas);
        canvas.id = "canvasid1";
        wrapper.appendChild(document.createElement('div')).className = 'keypoints-label';
        // mainContainer.appendChild(wrapper);

// Determine which workers to use based on extreme points
const handParts = [
    'leftHand', 'rightHand', 
    'leftUpperArmFront', 'leftUpperArmBack', 
    'leftLowerArmFront', 'leftLowerArmBack',
    'rightUpperArmFront', 'rightUpperArmBack', 
    'rightLowerArmFront', 'rightLowerArmBack'
];

const legParts = [
    'leftFoot', 'rightFoot',
    'leftUpperLegFront', 'leftUpperLegBack', 
    'leftLowerLegFront', 'leftLowerLegBack',
    'rightUpperLegFront', 'rightUpperLegBack', 
    'rightLowerLegFront', 'rightLowerLegBack'
];

// Check if any hand or leg parts are present
const hasHandParts = handParts.some(part => 
    extremePoints[part] && 
    Object.keys(extremePoints[part]).length > 0
);

const hasLegParts = legParts.some(part => 
    extremePoints[part] && 
    Object.keys(extremePoints[part]).length > 0
);

const workersToUse = [];
if (hasHandParts) {
    const postprocessingWorker = new Worker('handworker.js');
    workersToUse.push({
        worker: postprocessingWorker,
        type: 'hand'
    });
}

if (hasLegParts) {
    const legWorker = new Worker('legworker.js');
    workersToUse.push({
        worker: legWorker,
        type: 'leg'
    });
}

numberOfVariations = document.getElementById('imageCount').value;

const workerMessages = workersToUse.map(({type}) => ({
    type: e.data.type,
    imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),
    width: canvas.width,
    height: canvas.height,
    extremePoints,
    averages,
    timestamp: Date.now(),
    partNames,
    numberOfVariations, 
    bodyPartImages,
    rotationAngles: [0, 15, 20, 35, 46],
    imageArray
}));

let accumulatedVariations = [];

let totalVariationsExpected = numberOfVariations; // Assuming this is correctly set before processing starts

let totalworkerimages = 2 * numberOfVariations;

const generatedImages = [];
let combinedImagesProcessed = 0;

// Track already processed pairs
const processedPairs = new Set();

function attemptCombination() {
    for (let i = 0; i < totalworkerimages; i += 2) {
        // Stop if we already have the required number of combined images
        if (combinedImagesProcessed >= numberOfVariations) {
            break;
        }

        // Check if the pair has already been processed
        const pairKey = `${i}-${i + 1}`;
        if (generatedImages.length >= i + 2 && !processedPairs.has(pairKey)) {
            combineImagesByIndexes(i, i + 1); // Combine images in pairs
            processedPairs.add(pairKey); // Mark the pair as processed
            combinedImagesProcessed++;
        }
    }
}

// Overwrite the `push` method of the generatedImages array to trigger combination checks dynamically
const originalPush = generatedImages.push;
generatedImages.push = function (...args) {
    originalPush.apply(this, args);
    attemptCombination(); // Check if combinations can be processed
};

console.log('generatedImages :>> ', generatedImages);

function safelyCombineImages(img1, img2) {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = img1.width;
        canvas.height = img1.height;

        ctx.drawImage(img1, 0, 0);

        ctx.globalAlpha = 1;

        const x = (canvas.width - img2.width) / 2;
        const y = (canvas.height - img2.height) / 2;
        ctx.drawImage(img2, x, y);

        ctx.globalAlpha = 1;

        const combinedImg = new Image();
        combinedImg.onload = () => resolve(combinedImg);
        combinedImg.onerror = reject;
        combinedImg.src = canvas.toDataURL();
    });
}

function combineImagesByIndexes(index1, index2) {
    
    const firstImageType = generatedImages[index1].type;
    const secondImageType = generatedImages[index2].type;

    // console.log(`Attempting to combine - First Type: ${firstImageType}, Second Type: ${secondImageType}`);

    // Prevent combination if types are the same
    // if (firstImageType === secondImageType) {
    //     console.error(`Cannot combine images of the same type: ${firstImageType}`);
    //     return; // Exit the function immediately
    // }

    
    // if (generatedImages.length > Math.max(index1, index2)) {
    //     const imagePromises = [index1, index2].map(idx => {
    //         return new Promise((resolve, reject) => {
    //             const imgInfo = generatedImages[idx];
    //             const img = new Image();
    //             // // console.log('img :>> ', img);

    //             if (imgInfo.imageUrl) {
    //                 img.src = imgInfo.imageUrl;
    //             } else {
    //                 try {
    //                     img.src = createImageFromData(
    //                         imgInfo.imageData,
    //                         imgInfo.width,
    //                         imgInfo.height
    //                     );
    //                 } catch (error) {
    //                     console.error('Error creating image:', error);
    //                     reject(error);
    //                     return;
    //                 }
    //             }

    //             img.onload = () => resolve(img);
    //             img.onerror = reject;
    //         });
    //     });

    //     Promise.all(imagePromises)
    //         .then(([img1, img2]) => safelyCombineImages(img1, img2))
    //         .then(combinedImg => {
    //             const combinedContainer = document.createElement('div');
    //             combinedContainer.className = 'combined-images-container';

    //             const combinedWrapper = document.createElement('div');
    //             combinedWrapper.className = 'image-wrapper combined';
    //             combinedWrapper.appendChild(combinedImg);

    //             const verificationInfo = document.createElement('div');
    //             verificationInfo.className = 'verification-info';

    //             combinedContainer.appendChild(verificationInfo);
    //             combinedContainer.appendChild(combinedWrapper);

    //             const container = document.getElementById('imageContainer');
    //             container.appendChild(combinedContainer);

    //             // console.log(`Images at indexes ${index1} and ${index2} combined successfully`);
    //         })
    //         .catch(error => {
    //             console.error(`Error combining images at indexes ${index1} and ${index2}:`, error);

    //             const errorContainer = document.createElement('div');
    //             errorContainer.className = 'verification-info';
    //             errorContainer.textContent = `Error combining images: ${error.message}`;

    //             const container = document.getElementById('imageContainer');
    //             container.appendChild(errorContainer);
    //         });
      
    //     }


    }

const imageContainer = document.getElementById('imageContainer');
imageContainer.innerHTML = ''; // Clear existing content
imageContainer.style.position = 'relative';
imageContainer.style.height = '600px'; // Adjust as needed
imageContainer.style.overflow = 'hidden';

// Add styles
const style = document.createElement('style');
style.textContent = `
    #imageContainer {
        position: relative;
        width: 100%;
        margin: 20px 0;
        overflow: hidden;
    }

    .image-wrapper {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
     
    }

    .image-wrapper.active {
        opacity: 1;
    }

    .image-wrapper img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }
`;
document.head.appendChild(style);

// Promise.allSettled code remains the same
Promise.allSettled(
    workersToUse.map(({ worker }, index) =>
        new Promise((resolve, reject) => {
            worker.onmessage = (e) => {
                if (e.data.type === 'processedVariations') {
                    if (!e.data.variations || e.data.variations.length === 0) {
                        console.warn(`No variations for ${workersToUse[index].type} worker`);
                        return;
                    }

                    workersToUse[index].variations = e.data.variations;

                    e.data.variations.forEach((variation, variationIndex) => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'image-wrapper';
                        
                        const img = document.createElement('img');
                        img.src = variation.imageUrl || createImageFromData(
                            variation.imageData,
                            variation.width,
                            variation.height
                        );

                        wrapper.appendChild(img);
                        imageContainer.appendChild(wrapper);

                        generatedImages.push({
                            index: variationIndex,
                            type: workersToUse[index].type,
                            wrapper: wrapper,
                            image: img
                        });
                    });

                    // Start animation when all workers are done
                    if (index === workersToUse.length - 1) {
                        startSequentialAnimation();
                    }

                    resolve({
                        type: workersToUse[index].type,
                        variations: e.data.variations
                    });
                }
            };

            worker.onerror = (error) => {
                console.error('Worker error:', error);
                reject(error);
            };

            worker.postMessage(workerMessages[index]);
        })
    )
).catch(error => {
    console.error('Overall worker processing error:', error);
});


function startSequentialAnimation() {
    // Create a canvas for combining images
    const combinedCanvas = document.createElement('canvas');
    const ctx = combinedCanvas.getContext('2d');
    
    // Set canvas dimensions based on original image size
    combinedCanvas.width = generatedImages[0].image.width;
    combinedCanvas.height = generatedImages[0].image.height;
    
    // Group images by type
    const handImages = generatedImages.filter(img => img.type === 'hand');
    const legImages = generatedImages.filter(img => img.type === 'leg');
    
    // Create wrapper for combined images
    const combinedWrapper = document.createElement('div');
    combinedWrapper.className = 'image-wrapper active';
    imageContainer.appendChild(combinedWrapper);
    
    function combineAndShowImages(handIndex = 0, legIndex = 0) {
        // Clear canvas
        ctx.clearRect(0, 0, combinedCanvas.width, combinedCanvas.height);
        
        // Draw hand image
        if (handImages[handIndex]) {
            ctx.globalAlpha = 1;
            ctx.drawImage(handImages[handIndex].image, 0, 0);
        }
        
        // Draw leg image
        if (legImages[legIndex]) {
            ctx.globalAlpha = 1;
            ctx.drawImage(legImages[legIndex].image, 0, 0);
        }
        
        // Create combined image
        const combinedImage = new Image();
        combinedImage.src = combinedCanvas.toDataURL();
        
        // Update display
        combinedWrapper.innerHTML = '';
        combinedWrapper.appendChild(combinedImage);
        
        // Schedule next combination if needed
        setTimeout(() => {
            const nextHandIndex = (handIndex + 1) % handImages.length;
            const nextLegIndex = (legIndex + 1) % legImages.length;
            combineAndShowImages(nextHandIndex, nextLegIndex);
        }, 200);
    }
    
    // Start the combination process
    combineAndShowImages();
}

// Update the worker processing section
Promise.allSettled(
    workersToUse.map(({ worker }, index) =>
        new Promise((resolve, reject) => {
            worker.onmessage = (e) => {
                if (e.data.type === 'processedVariations') {
                    if (!e.data.variations || e.data.variations.length === 0) {
                        console.warn(`No variations for ${workersToUse[index].type} worker`);
                        return;
                    }

                    workersToUse[index].variations = e.data.variations;

                    e.data.variations.forEach((variation, variationIndex) => {
                        const img = new Image();
                        img.src = variation.imageUrl || createImageFromData(
                            variation.imageData,
                            variation.width,
                            variation.height
                        );

                        generatedImages.push({
                            index: variationIndex,
                            type: workersToUse[index].type,
                            image: img,
                            width: variation.width,
                            height: variation.height
                        });
                    });

                    // Start animation when all workers are done
                    if (generatedImages.length === totalworkerimages) {
                        startSequentialAnimation();
                    }

                    resolve({
                        type: workersToUse[index].type,
                        variations: e.data.variations
                    });
                }
            };

            worker.onerror = (error) => {
                console.error('Worker error:', error);
                reject(error);
            };

            worker.postMessage(workerMessages[index]);
        })
    )
).catch(error => {
    console.error('Overall worker processing error:', error);
});


// Helper function to create an image from ImageData
function createImageFromData(imageData, width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    // const ctx = canvas.getContext('2d');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    ctx.putImageData(new ImageData(imageData, width, height), 0, 0);
    return canvas.toDataURL();
}

}
 
    };




}

        let originalImageData;
        let maskData; 
        let size;
        let objectMask;
        let lines = [];
        // console.log(effects);
        
        effects.forEach(effect => {
            const controlDiv = document.createElement('div');
            controlDiv.className = 'effect-control';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `${effect}Checkbox`;
            checkbox.checked = true;
            checkbox.addEventListener('change', updateMasterCheckbox);
            const label = document.createElement('label');
            label.htmlFor = `${effect}Checkbox`;
            label.textContent = effect;
            controlDiv.appendChild(checkbox);
            controlDiv.appendChild(label);
            effectControls.appendChild(controlDiv);
        }); 

        function compressImage(file, callback) {
    const reader = new FileReader();
    reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Set the desired maximum width and height
            const MAX_DIMENSION = 800; // Maximum allowed dimension (width or height)
            let width = img.width;
            let height = img.height;

            // Check if either width or height exceeds the maximum dimension
            if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
                if (width > height) {
                    // Resize based on width
                    height *= MAX_DIMENSION / width;
                    width = MAX_DIMENSION;
                } else {
                    // Resize based on height
                    width *= MAX_DIMENSION / height;
                    height = MAX_DIMENSION;
                }
            }

            // Set canvas dimensions
            canvas.width = width;
            canvas.height = height;

            // Draw the image on the canvas with the new dimensions
            ctx.drawImage(img, 0, 0, width, height);

            // Convert the canvas content to a data URL with reduced quality
            canvas.toBlob((blob) => {
                callback(blob);
            }, 'image/jpeg', 0.7); // Adjust the quality (0.7 means 70% quality)
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
}


        
        // document.getElementById('imageUpload').addEventListener('change', (event) => {
        //     const file = event.target.files[0];
        //     if (file) {
        //         const reader = new FileReader();
        //         reader.onload = (e) => {
        //             const img = new Image();
        //             img.onload = () => {
        //                 // Check if either width or height exceeds 800px
        //                 console.log(img.width);
        //                 console.log(img.height);
        //                 if (img.width > 600 || img.height > 600) {
        //                     // Compress the image
        //                     compressImage(file, (compressedBlob) => {
        //                         const compressedReader = new FileReader();
        //                         compressedReader.onload = (e) => {
        //                             originalImage = new Image();
        //                             originalImage.onload = () => {
        //                                 imageCanvas.width = originalImage.width;
        //                                 imageCanvas.height = originalImage.height;
        //                                 ctx.drawImage(originalImage, 0, 0);
        //                                 originalImageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
        //                                 maskData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height); // Initialize maskData
        //                                 size = { w: imageCanvas.width, h: imageCanvas.height }; // Initialize size
        //                                 objectMask = matrix(imageCanvas.width, imageCanvas.height, false); // Initialize objectMask
        //                             };
        //                             originalImage.onerror = (error) => {
        //                                 console.error('Error loading image:', error);
        //                                 alert('Failed to load the image. Please try again.');
        //                             };
        //                             originalImage.src = e.target.result; // Load the compressed image into the canvas
        //                         };
        //                         compressedReader.onerror = (error) => {
        //                             console.error('Error reading compressed file:', error);
        //                             alert('Failed to read the compressed file. Please try again.');
        //                         };
        //                         compressedReader.readAsDataURL(compressedBlob); // Read the compressed blob as a data URL
        //                     });
        //                 } else {
        //                     // If dimensions are within limits, load the image directly
        //                     originalImage = new Image();
        //                     originalImage.onload = () => {
        //                         imageCanvas.width = originalImage.width;
        //                         imageCanvas.height = originalImage.height;
        //                         ctx.drawImage(originalImage, 0, 0);
        //                         originalImageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
        //                         maskData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height); // Initialize maskData
        //                         size = { w: imageCanvas.width, h: imageCanvas.height }; // Initialize size
        //                         objectMask = matrix(imageCanvas.width, imageCanvas.height, false); // Initialize objectMask
        //                     };
        //                     originalImage.onerror = (error) => {
        //                         console.error('Error loading image:', error);
        //                         alert('Failed to load the image. Please try again.');
        //                     };
        //                     originalImage.src = e.target.result; // Load the image into the canvas
        //                 }
        //             };
        //             img.src = e.target.result;
        //         };
        //         reader.onerror = (error) => {
        //             console.error('Error reading file:', error);
        //             alert('Failed to read the file. Please try again.');
        //         };
        //         reader.readAsDataURL(file); // Read the file as a data URL
        //     }
        // });


        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    originalImage = new Image();
                    originalImage.onload = () => {
                        imageCanvas.width = originalImage.width;
                        imageCanvas.height = originalImage.height;
                        // imageCanvas.id = "icid"
                        
                        ctx.drawImage(originalImage, 0, 0);
                        
                        originalImageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
                        maskData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height); // Initialize maskData
                        size = { w: imageCanvas.width, h: imageCanvas.height }; // Initialize size
                        objectMask = matrix(imageCanvas.width, imageCanvas.height, false); // Initialize objectMask

                    };
                    originalImage.onerror = (error) => {
                        console.error('Error loading image:', error);
                        alert('Failed to load the image. Please try again.');
                    };
                    originalImage.src = e.target.result; // Load the image into the canvas
                };
                reader.onerror = (error) => {
                    console.error('Error reading file:', error);
                    alert('Failed to read the file. Please try again.');
                };
                reader.readAsDataURL(file); // Read the file as a data URL
            }
        });

        
        function loadImage() {
            originalImage = new Image();
            originalImage.onload = function() {
                imageCanvas.width = originalImage.width;
                imageCanvas.height = originalImage.height;
                ctx.drawImage(originalImage, 0, 0);
                originalImageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
                maskData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height); // Initialize maskData
                size = { w: imageCanvas.width, h: imageCanvas.height }; // Initialize size
                objectMask = matrix(imageCanvas.width, imageCanvas.height, false); // Initialize objectMask
                window.uploadedImageData = originalImageData;
                // imageCanvas.id = "icid1"

                displaySelectedRegionsBorders();
            }

            // originalImage.src = 'face.jpg'; // Ensure this path is correct

        }


        </script>
</body>
</html>
